<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Музыкальная Студия</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    /* Общий стиль */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Montserrat', sans-serif;
      background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-y: auto; /* Вертикальная прокрутка */
      overflow-x: hidden; /* Запрещаем горизонтальную прокрутку */
      touch-action: manipulation; /* Улучшает отзывчивость на мобильных */
    }
    .container {
      width: 100%;
      max-width: 800px;
      margin: 20px auto;
      background: rgba(255,255,255,0.9);
      border-radius: 10px;
      padding: 15px; /* Уменьшили отступы для мобильных */
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      box-sizing: border-box;
    }
    section {
      margin-bottom: 25px; /* Уменьшили отступы */
    }
    section h2 {
      margin-top: 0;
      color: #444;
      display: inline-block;
      vertical-align: middle;
      font-size: 1.2em; /* Уменьшили размер шрифта для мобильных */
    }
    /* Кнопка "?" – выравнивание */
    .info-btn {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 20px; /* Уменьшили размер */
      height: 20px;
      font-size: 12px;
      font-weight: bold;
      margin-left: 5px;
      cursor: pointer;
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
    }
    button, input[type="file"] {
      padding: 8px 16px; /* Уменьшили отступы */
      font-size: 0.9em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-right: 8px;
      background: #66a6ff;
      color: #fff;
      transition: background 0.2s;
      touch-action: manipulation;
    }
    button:hover {
      background: #5594e6;
    }
    button:disabled {
      background: #a3c4ff;
      cursor: not-allowed;
    }
    .control-group {
      margin-bottom: 12px; /* Уменьшили отступы */
    }
    label {
      display: block;
      margin-bottom: 4px;
      font-weight: bold;
      font-size: 0.9em;
    }
    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      background: #ddd;
      height: 6px; /* Уменьшили высоту */
      border-radius: 4px;
      outline: none;
      touch-action: manipulation;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; /* Уменьшили размер */
      height: 18px;
      border-radius: 50%;
      background: #66a6ff;
      cursor: pointer;
      transition: background 0.2s;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      background: #5594e6;
    }
    .value-display {
      text-align: right;
      font-size: 0.8em;
      margin-top: 4px;
    }
    audio {
      width: 100%;
      margin-top: 8px;
      outline: none;
    }
    /* Блок дополнительных настроек */
    .extra-tools-section {
      margin-bottom: 25px;
    }
    #toggleExtra {
      background: #ffb74d;
      color: #fff;
      margin-bottom: 8px;
      width: 100%; /* Полная ширина на мобильных */
    }
    #extraTools {
      display: none;
      border-top: 1px solid #ccc;
      padding-top: 12px;
    }
    .extra-control {
      margin-bottom: 8px;
    }
    /* Модальное окно */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      overflow-y: auto; /* Прокрутка в модальном окне */
    }
    .modal-content {
      background: #fff;
      color: #333;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      max-width: 90%;
      width: auto;
      max-height: 80vh;
      overflow-y: auto;
      box-sizing: border-box;
    }
    .modal-content p {
      margin: 8px 0;
    }
    .modal-content ul {
      list-style: none;
      padding: 0;
      text-align: left;
    }
    .modal-content li {
      margin: 4px 0;
    }
    .modal-content button {
      margin-top: 8px;
      padding: 4px 8px;
      border: none;
      border-radius: 5px;
      background: #66a6ff;
      color: #fff;
      cursor: pointer;
    }
    /* Кнопка сброса */
    #resetBaseBtn {
      margin-top: 12px;
      background: #e57373;
    }
    /* Секция загрузки файла */
    .upload-section input[type="file"] {
      display: block;
      margin-top: 8px;
      width: 100%;
    }
    /* Новый стиль для визуализатора на фоне */
    canvas#visualizerBackground {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      display: none;
    }
    /* Стиль для кнопки "Вернуться в главное меню" */
    #backBtn {
      padding: 8px 16px;
      font-size: 14px;
      z-index: 999;
      position: fixed;
      top: 10px;
      left: 10px;
    }
    /* Медиа-запросы для мобильных устройств */
    @media (max-width: 600px) {
      .container {
        margin: 10px;
        padding: 10px;
      }
      section h2 {
        font-size: 1.1em;
      }
      button, input[type="file"] {
        padding: 6px 12px;
        font-size: 0.8em;
      }
      .info-btn {
        width: 18px;
        height: 18px;
        font-size: 11px;
      }
      input[type="range"] {
        height: 5px;
      }
      input[type="range"]::-webkit-slider-thumb {
        width: 16px;
        height: 16px;
      }
      .value-display {
        font-size: 0.75em;
      }
      .modal-content {
        padding: 10px;
        max-height: 70vh;
      }
      /* На мобильных кнопка сверху надписи, не фиксированная */
      #backBtn {
        position: static;
        display: block;
        margin: 0 auto 20px auto;
        width: fit-content;
      }
      .play-section {
        margin-top: 0; /* Убираем отступ сверху для секции */
      }
    }
    /* Прокрутка справа (по умолчанию на мобильных она справа) */
    /* Нет нужды добавлять что-то дополнительно, так как по умолчанию прокрутка справа */
  </style>
</head>
<body>
  <!-- Фон с визуализатором -->
  <canvas id="visualizerBackground"></canvas>
  
  <div class="container">
    <button id="backBtn" onclick="window.location.href = 'main.html'">
      ВЕРНУТЬСЯ В ГЛАВНОЕ МЕНЮ
    </button>

    <!-- Загрузка файла -->
    <section class="upload-section">
      <h2>Загрузите свою песню</h2>
      <input type="file" id="audioUpload" accept="audio/*">
    </section>
    
    <!-- Проигрывание и базовые эффекты -->
    <section class="play-section">
      <h2>
        Проигрывание и базовые эффекты
        <button id="baseInfoBtn" class="info-btn" type="button" data-info="Громкость: Управляет уровнем звука через усилитель. Значение 1 – нейтральное, меньше 1 – тише, больше 1 – громче.&#10;Задержка: Добавляет эхо; 0 – без эха.">?</button>
      </h2>
      <!-- Автозапуск отключён – пользователь нажимает Play -->
      <audio id="audioPlayer" controls></audio>
      <div class="control-group">
        <label for="volumeControl">Громкость (0 - 24):
          <button class="info-btn" data-info="Базовая настройка громкости. Значение 1 означает отсутствие усиления. При увеличении значения звук становится громче, при уменьшении – тише." type="button">?</button>
        </label>
        <input type="range" id="volumeControl" min="0" max="24" step="0.01" value="1">
        <div class="value-display">Значение: <span id="volumeValue">1.00</span></div>
      </div>
      <div class="control-group">
        <label for="delayControl">Эффект задержки (0 - 1 сек):
          <button class="info-btn" data-info="Базовая настройка задержки (эхо). Значение 0 – без эффекта, а значения до 1 секунды добавляют эхо." type="button">?</button>
        </label>
        <input type="range" id="delayControl" min="0" max="1" step="0.01" value="0">
        <div class="value-display">Значение: <span id="delayValue">0.00</span> сек</div>
      </div>
    </section>
    
    <!-- Дополнительные настройки -->
    <section class="extra-tools-section">
      <button id="toggleExtra">Развернуть⬇️</button>
      <div id="extraTools">
        <h2>Дополнительные настройки</h2>
        <div id="extraControls"><!-- Контролы генерируются автоматически --></div>
      </div>
    </section>

    <!-- Кнопка поделиться -->
    <section class="share-section">
      <button id="shareMusicBtn" disabled>Поделиться музыкой (Premium)</button>
    </section>
  </div>
  
  <!-- Модальное окно (ошибка выбора файла) -->
  <div id="overlay" class="modal-overlay">
    <div class="modal-content">
      Файл не выбран.<br>
      Пожалуйста выберите файл перед тем как прослушать его!
      <br>
      <button id="closeOverlay">Закрыть</button>
    </div>
  </div>
  
  <!-- Модальное окно для настроек -->
  <div id="infoModal" class="modal-overlay">
    <div class="modal-content" id="infoModalContent">
      <!-- Содержимое генерируется динамически -->
      <button id="closeInfoModal">Закрыть</button>
    </div>
  </div>
  
  <script>
    // Первая часть кода (запомненная)
    let originalFileName = '';
    let audioFile = null; // выбранный файл для шаринга
    const audioPlayer = document.getElementById('audioPlayer');
    const audioUpload = document.getElementById('audioUpload');
    const shareMusicBtn = document.getElementById('shareMusicBtn');
    const volumeControl = document.getElementById('volumeControl');
    const volumeValue = document.getElementById('volumeValue');
    const delayControl = document.getElementById('delayControl');
    const delayValue = document.getElementById('delayValue');
    
    // Вторая часть кода (запомненная)
    const extraTools = document.getElementById('extraTools');
    const extraControlsContainer = document.getElementById('extraControls');
    const closeOverlay = document.getElementById('closeOverlay');
    const baseInfoBtn = document.getElementById('baseInfoBtn');
    
    const infoModal = document.getElementById('infoModal');
    const infoModalContent = document.getElementById('infoModalContent');
    const closeInfoModal = document.getElementById('closeInfoModal');
    
    let audioContext, sourceNode, gainNode, delayNode;
    let extraEffects = [];
    let extraControlsGenerated = false;
    let bypassExtraEffects = true; // Флаг: если все extra-слайдеры на нейтральном уровне – эффекты не применяются
    
    // Проверка премиума
    const premium = localStorage.getItem('premium');
    if (premium) {
      shareMusicBtn.disabled = false;
      shareMusicBtn.textContent = 'Поделиться музыкой';
    }

    // Обработчик кнопки "Поделиться музыкой"
    shareMusicBtn.addEventListener('click', async () => {
      if (!audioFile) {
        alert("Пожалуйста, выберите файл с песней.");
        return;
      }
      shareMusicBtn.disabled = true;
      const processedBlob = await renderProcessedAudio();
      shareMusicBtn.disabled = false;
      if (!processedBlob) {
        alert("Ошибка при обработке аудио.");
        return;
      }
      const fileExt = originalFileName.split('.').pop();
      const newFileName = originalFileName.replace(`.${fileExt}`, `_processed.wav`);
      const processedFile = new File([processedBlob], newFileName, {type: 'audio/wav'});
      const settingsText = getCurrentSettings();
      if (navigator.canShare && navigator.canShare({ files: [processedFile] })) {
        try {
          await navigator.share({
            title: 'Моя музыка',
            text: settingsText,
            files: [processedFile]
          });
        } catch (error) {
          alert("Ошибка при попытке поделиться: " + error);
        }
      } else {
        alert("Ваш браузер не поддерживает совместное использование файлов.");
      }
    });
    
    function getCurrentSettings() {
      let settings = "Базовые настройки:\n";
      settings += "Громкость: " + volumeControl.value + "\n";
      settings += "Задержка: " + delayControl.value + " сек\n\n";
      settings += "Дополнительные настройки:\n";
      for (let i = 0; i < extraEffectsConfig.length; i++) {
        const slider = document.getElementById('extraControl' + i);
        if (slider) {
          settings += extraEffectsConfig[i].name + ": " + slider.value + "\n";
        }
      }
      return settings;
    }
    
    // Функция, которая всегда перестраивает цепочку дополнительных эффектов
    function rebuildExtraEffectsChain() {
      delayNode.disconnect();
      if (extraEffects.length > 0) {
        delayNode.connect(extraEffects[0].node);
        for (let i = 0; i < extraEffects.length - 1; i++) {
          try { extraEffects[i].node.disconnect(); } catch(e){}
          extraEffects[i].node.connect(extraEffects[i+1].node);
        }
        try { extraEffects[extraEffects.length - 1].node.disconnect(); } catch(e){}
        extraEffects[extraEffects.length - 1].node.connect(audioContext.destination);
        bypassExtraEffects = false;
      } else {
        delayNode.connect(audioContext.destination);
        bypassExtraEffects = true;
      }
    }
    
    // Вызывается при изменении слайдера дополнительных настроек
    function extraSliderChanged() {
      rebuildExtraEffectsChain();
    }
    
    // Список дополнительных настроек с обновлёнными описаниями (info)
    const extraEffectsConfig = [
      { name: 'Lowshelf (Bass, Управление низкими частотами)', type: 'lowshelf', min: -20, max: 20, step: 1, value: 0, info: 'Этот фильтр позволяет управлять низкими частотами. При значении 0 звук не изменяется, положительные значения усиливают бас, отрицательные – уменьшают его.' },
      { name: 'Distortion (Искажение)', type: 'distortion', min: 0, max: 1000, step: 1, value: 0, info: 'Эффект искажения добавляет перегрузку, создавая характерное «грязное» звучание. Значение 0 означает отсутствие искажения.' },
      { name: 'Highpass (Убирает низкие частоты)', type: 'highpass', min: 20, max: 2000, step: 1, value: 20, info: 'Фильтр Highpass отсекает низкие частоты ниже заданного порога. Значение 20 Гц – минимальное отсечение.' },
      { name: 'Lowpass (Убирает высокие частоты)', type: 'lowpass', min: 1000, max: 22050, step: 1, value: 22050, info: 'Фильтр Lowpass отсекает высокие частоты выше заданного значения. При 22050 Гц эффект не применяется.' },
      { name: 'Panner (Стереопозиционирование)', type: 'panner', min: -1, max: 1, step: 0.01, value: 0, info: 'Панорамирование позволяет управлять положением звука в стереопространстве. Значение 0 означает, что звук находится по центру.' },
      { name: 'Compressor (Сжатие динамического диапазона)', type: 'compressor', min: -100, max: 0, step: 1, value: -100, info: 'Компрессор уменьшает динамический диапазон, делая пики звука менее резкими. Значение -100 означает отсутствие компрессии.' },
      { name: 'Delay (Вторичная задержка)', type: 'delay', min: 0, max: 0.5, step: 0.01, value: 0, info: 'Эффект задержки добавляет эхо. Значение 0 означает отсутствие задержки.' },
      { name: 'Notch (Фильтр Notch)', type: 'notch', min: 0, max: 2000, step: 1, value: 0, info: 'Notch-фильтр удаляет узкий диапазон частот для устранения нежелательных резонансов.' },
      { name: 'Peaking (Эквалайзер)', type: 'peaking', min: -20, max: 20, step: 1, value: 0, info: 'Peaking-фильтр позволяет усилить или ослабить определённый диапазон частот. Значение 0 – без изменений.' },
      { name: 'Gain Booster (Усиление)', type: 'gain', min: 1, max: 3, step: 0.01, value: 1, info: 'Этот усилитель увеличивает общий уровень сигнала. Значение 1 означает отсутствие усиления.' },
      { name: 'Tremolo (Модуляция амплитуды)', type: 'tremolo', min: 0, max: 1, step: 0.01, value: 0, info: 'Тремоло создает эффект пульсации звука за счет периодической модуляции амплитуды. При 0 эффекта нет.' },
      { name: 'Bandpass (Пропускает узкий диапазон)', type: 'bandpass', min: 0, max: 3000, step: 1, value: 0, info: 'Bandpass-фильтр пропускает только определённый диапазон частот. При 0 эффект не применяется.' },
      { name: 'Allpass (Фазовый сдвиг)', type: 'allpass', min: 300, max: 3000, step: 1, value: 1000, info: 'Allpass-фильтр изменяет фазу сигнала, не затрагивая амплитуду. Это позволяет создавать интересные пространственные эффекты.' },
      { name: 'Highshelf (Управление высокими частотами)', type: 'highshelf', min: -20, max: 20, step: 1, value: 0, info: 'Этот фильтр позволяет регулировать высокие частоты, влияя на яркость и четкость звука. Значение 0 – без изменений.' },
      { name: 'Reverb (Реверберация)', type: 'reverb', min: 0, max: 1, step: 0.01, value: 0, info: 'Реверберация симулирует акустику помещения, добавляя глубину и объем звуку. Значение 0 означает отсутствие реверберации.' },
      { name: 'Flanger (Эффект Flanger)', type: 'flanger', min: 0, max: 0.005, step: 0.0001, value: 0, info: 'Flanger создает эффект «вращения» звука за счет изменения задержки. При 0 эффект не применяется.' },
      { name: 'Chorus (Эффект Chorus)', type: 'chorus', min: 0, max: 0.03, step: 0.001, value: 0, info: 'Chorus добавляет слегка смещенные копии сигнала, делая звук шире и богаче. Значение 0 – без эффекта.' },
      { name: 'Vibrato (Модуляция высоты тона)', type: 'vibrato', min: 0, max: 1, step: 0.01, value: 0, info: 'Вибрато изменяет высоту тона звука, создавая эффект колебаний. При 0 эффект отсутствует.' },
      { name: 'Phaser (Фазовый эффект)', type: 'phaser', min: 0, max: 1, step: 0.01, value: 0, info: 'Фазовый эффект создает характерное «вращающееся» звучание за счет периодических изменений фазы сигнала. При 0 изменений нет.' },
      { name: 'AutoWah (Эффект Wah)', type: 'autowah', min: 0, max: 1, step: 0.01, value: 0, info: 'AutoWah автоматически изменяет фильтрацию сигнала в зависимости от его динамики, создавая эффект «wah-wah». При 0 эффекта нет.' },
      { name: 'Playback Rate (Скорость воспроизведения)', type: 'playbackRate', min: 0.5, max: 2.0, step: 0.01, value: 1, info: 'Изменение скорости воспроизведения изменяет темп и высоту тона звука. Значение 1 – нормальная скорость.' },
      { name: 'Bitcrusher (Эффект lo‑fi)', type: 'bitcrusher', min: 1, max: 16, step: 1, value: 16, info: 'Bitcrusher уменьшает битовую глубину сигнала, создавая эффект lo‑fi. Значение 16 означает максимально качественное звучание (без эффекта).' }
    ];

    function createImpulseResponse(ctx, duration, decay) {
      const length = ctx.sampleRate * duration;
      const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
      const impulseL = impulse.getChannelData(0);
      const impulseR = impulse.getChannelData(1);
      for (let i = 0; i < length; i++) {
        const n = decay ? Math.exp(-i / (ctx.sampleRate * decay)) : 1;
        impulseL[i] = (Math.random() * 2 - 1) * n;
        impulseR[i] = (Math.random() * 2 - 1) * n;
      }
      return impulse;
    }
    
    // Функция создания extra-эффекта с bypass-логикой
    function createExtraEffect(cfg, ctx = audioContext) {
      let node;
      let extraData = { config: cfg };
      switch(cfg.type) {
        case 'lowshelf':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createBiquadFilter();
            node.type = 'lowshelf';
            node.frequency.value = 200;
            node.gain.value = cfg.value;
          }
          break;
        case 'distortion':
          node = ctx.createWaveShaper();
          node.curve = makeDistortionCurve(cfg.value);
          break;
        case 'highpass':
          if (cfg.value == 20) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createBiquadFilter();
            node.type = 'highpass';
            node.frequency.value = cfg.value;
          }
          break;
        case 'lowpass':
          if (cfg.value == 22050) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createBiquadFilter();
            node.type = 'lowpass';
            node.frequency.value = cfg.value;
          }
          break;
        case 'panner':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createStereoPanner();
            node.pan.value = cfg.value;
          }
          break;
        case 'compressor':
          if (cfg.value == -100) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createDynamicsCompressor();
            node.threshold.value = cfg.value;
          }
          break;
        case 'delay':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createDelay(1.0);
            node.delayTime.value = cfg.value;
          }
          break;
        case 'notch':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createBiquadFilter();
            node.type = 'notch';
            node.frequency.value = cfg.value;
          }
          break;
        case 'peaking':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createBiquadFilter();
            node.type = 'peaking';
            node.gain.value = cfg.value;
          }
          break;
        case 'gain':
          if (cfg.value == 1) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createGain();
            node.gain.value = cfg.value;
          }
          break;
        case 'tremolo':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createGain();
            node.gain.value = 1;
            const tremoloOsc = ctx.createOscillator();
            tremoloOsc.type = 'sine';
            tremoloOsc.frequency.value = 5;
            const tremoloGain = ctx.createGain();
            tremoloGain.gain.value = cfg.value;
            tremoloOsc.connect(tremoloGain);
            tremoloGain.connect(node.gain);
            tremoloOsc.start(0);
            extraData.tremoloOsc = tremoloOsc;
            extraData.tremoloGain = tremoloGain;
          }
          break;
        case 'bandpass':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createBiquadFilter();
            node.type = 'bandpass';
            node.frequency.value = cfg.value;
          }
          break;
        case 'allpass':
          node = ctx.createBiquadFilter();
          node.type = 'allpass';
          node.frequency.value = cfg.value;
          break;
        case 'highshelf':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createBiquadFilter();
            node.type = 'highshelf';
            node.frequency.value = 5000;
            node.gain.value = cfg.value;
          }
          break;
        case 'reverb':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            const convolver = ctx.createConvolver();
            convolver.buffer = createImpulseResponse(ctx, 2.0, 2.0);
            const reverbGain = ctx.createGain();
            reverbGain.gain.value = cfg.value;
            convolver.connect(reverbGain);
            node = reverbGain;
            extraData.convolver = convolver;
          }
          break;
        case 'flanger':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createDelay();
            node.delayTime.value = cfg.value;
            const flangerOsc = ctx.createOscillator();
            flangerOsc.type = 'sine';
            flangerOsc.frequency.value = 0.25;
            const flangerGain = ctx.createGain();
            flangerGain.gain.value = cfg.value;
            flangerOsc.connect(flangerGain);
            flangerGain.connect(node.delayTime);
            flangerOsc.start(0);
            extraData.flangerOsc = flangerOsc;
          }
          break;
        case 'chorus':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createDelay();
            node.delayTime.value = cfg.value;
            const chorusOsc = ctx.createOscillator();
            chorusOsc.type = 'sine';
            chorusOsc.frequency.value = 1.5;
            const chorusGain = ctx.createGain();
            chorusGain.gain.value = cfg.value;
            chorusOsc.connect(chorusGain);
            chorusGain.connect(node.delayTime);
            chorusOsc.start(0);
            extraData.chorusOsc = chorusOsc;
          }
          break;
        case 'vibrato':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createGain();
            node.gain.value = cfg.value;
          }
          break;
        case 'phaser':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createGain();
            node.gain.value = cfg.value;
          }
          break;
        case 'autowah':
          if (cfg.value == 0) {
            node = ctx.createGain();
            node.gain.value = 1;
          } else {
            node = ctx.createGain();
            node.gain.value = cfg.value;
          }
          break;
        case 'playbackRate':
          node = ctx.createGain();
          break;
        case 'bitcrusher':
          node = ctx.createScriptProcessor(4096, 1, 1);
          node.bits = cfg.value;
          node.onaudioprocess = function(e) {
            const input = e.inputBuffer.getChannelData(0);
            const output = e.outputBuffer.getChannelData(0);
            const step = Math.pow(0.5, node.bits);
            for (let i = 0; i < input.length; i++) {
              output[i] = step * Math.floor(input[i] / step + 0.5);
            }
          };
          break;
        default:
          node = ctx.createGain();
          node.gain.value = cfg.value;
      }
      extraData.node = node;
      return extraData;
    }
    
    // Функция создания кривой дисторшна – если amount равен 0, возвращает линейную кривую
    function makeDistortionCurve(amount) {
      const n_samples = 44100;
      const curve = new Float32Array(n_samples);
      if (amount === 0) {
        for (let i = 0; i < n_samples; i++) {
          curve[i] = i * 2 / n_samples - 1;
        }
        return curve;
      }
      const deg = Math.PI / 180;
      for (let i = 0; i < n_samples; ++i) {
        const x = i * 2 / n_samples - 1;
        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
      }
      return curve;
    }
    
    // Инициализация AudioContext и цепочки узлов
    function initAudioContext() {
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      audioContext.resume();
      // Аудио-элемент остается muted – звук выводится через AudioContext
      audioPlayer.muted = true;
      
      sourceNode = audioContext.createMediaElementSource(audioPlayer);
      gainNode = audioContext.createGain();
      delayNode = audioContext.createDelay(2.0);
      
      extraEffects = extraEffectsConfig.map(cfg => createExtraEffect(cfg));
      
      sourceNode.connect(gainNode);
      gainNode.connect(delayNode);
      // Если все extra-слайдеры на нейтральном уровне, цепочка не применяется
      bypassExtraEffects = true;
      delayNode.connect(audioContext.destination);
      
      if (!extraControlsGenerated) {
        generateExtraControls();
        extraControlsGenerated = true;
      }
    }
    
    // Генерация UI для дополнительных настроек
    function generateExtraControls() {
      extraEffects.forEach((effectData, index) => {
        const cfg = effectData.config;
        const controlDiv = document.createElement('div');
        controlDiv.classList.add('extra-control');
        
        const label = document.createElement('label');
        label.setAttribute('for', `extraControl${index}`);
        label.innerHTML = `${cfg.name}: `;
        const btn = document.createElement('button');
        btn.classList.add('info-btn');
        btn.type = "button";
        btn.textContent = "?";
        btn.addEventListener('click', () => {
          openInfoModal(cfg.info);
        });
        label.appendChild(btn);
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.id = `extraControl${index}`;
        slider.min = cfg.min;
        slider.max = cfg.max;
        slider.step = cfg.step;
        slider.value = cfg.value;
        
        const valueDisplay = document.createElement('div');
        valueDisplay.classList.add('value-display');
        valueDisplay.textContent = `Значение: ${slider.value}`;
        
        slider.addEventListener('input', () => {
          const val = parseFloat(slider.value);
          valueDisplay.textContent = `Значение: ${slider.value}`;
          const thisCfg = extraEffectsConfig[index];
          if (thisCfg.type === 'playbackRate') {
            audioPlayer.playbackRate = val;
          } else {
            const newCfg = {...thisCfg, value: val};
            extraEffects[index] = createExtraEffect(newCfg, audioContext);
          }
          extraSliderChanged();
        });
        
        controlDiv.appendChild(label);
        controlDiv.appendChild(slider);
        controlDiv.appendChild(valueDisplay);
        extraControlsContainer.appendChild(controlDiv);
      });
    }
    
    // Функция открытия модального окна
    function openInfoModal(message, extraContent = '') {
      infoModalContent.innerHTML = `<p>${message}</p>${extraContent}<br><button id="closeInfoModal">Закрыть</button>`;
      document.getElementById('closeInfoModal').addEventListener('click', () => {
        infoModal.style.display = 'none';
      });
      infoModal.style.display = 'flex';
      
      setTimeout(() => {
        document.querySelectorAll('.reset-single').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const setting = e.target.getAttribute('data-setting');
            if (setting === 'volume') {
              volumeControl.value = 1;
              volumeValue.textContent = '1.00';
              if (gainNode) gainNode.gain.value = 1;
              e.target.parentElement.innerHTML = `<strong>Громкость:</strong> 1 <button class="reset-single" data-setting="volume">🔁</button>`;
            } else if (setting === 'delay') {
              delayControl.value = 0;
              delayValue.textContent = '0.00';
              if (delayNode) delayNode.delayTime.value = 0;
              e.target.parentElement.innerHTML = `<strong>Задержка:</strong> 0 сек <button class="reset-single" data-setting="delay">🔁</button>`;
            } else if (e.target.hasAttribute('data-extra-index')) {
              const index = e.target.getAttribute('data-extra-index');
              const cfg = extraEffectsConfig[index];
              const slider = document.getElementById('extraControl' + index);
              if (slider) {
                slider.value = cfg.value;
                const display = slider.parentElement.querySelector('.value-display');
                if (display) display.textContent = `Значение: ${cfg.value}`;
                slider.dispatchEvent(new Event('input'));
                const li = document.querySelector('li[data-extra-index="'+index+'"]');
                if (li) {
                  li.innerHTML = `<strong>${cfg.name}:</strong> ${cfg.value} <button class="reset-single" data-extra-index="${index}">🔁</button>`;
                }
              }
            }
          });
        });
      }, 100);
    }
    
    // Обработчик кнопки информации (Базовые настройки)
    baseInfoBtn.addEventListener('click', () => {
      if (!audioPlayer.src) {
        openInfoModal("Файл не выбран.<br>Пожалуйста выберите файл перед тем как прослушать его!");
        return;
      }
      let changedBase = "";
      if (parseFloat(volumeControl.value) !== 1) {
        changedBase += `<p><strong>Громкость:</strong> ${volumeControl.value} <button class="reset-single" data-setting="volume">🔁</button></p>`;
      }
      if (parseFloat(delayControl.value) !== 0) {
        changedBase += `<p><strong>Задержка:</strong> ${delayControl.value} сек <button class="reset-single" data-setting="delay">🔁</button></p>`;
      }
      let changedExtras = "";
      for (let i = 0; i < extraEffectsConfig.length; i++) {
        const slider = document.getElementById('extraControl' + i);
        if (slider && parseFloat(slider.value) !== parseFloat(extraEffectsConfig[i].value)) {
          changedExtras += `<li data-extra-index="${i}"><strong>${extraEffectsConfig[i].name}:</strong> ${slider.value} <button class="reset-single" data-extra-index="${i}">🔁</button></li>`;
        }
      }
      let modalMessage = "";
      if (changedBase || changedExtras) {
        if (changedBase) {
          modalMessage += `<p><strong>Базовые настройки:</strong></p>` + changedBase;
        }
        if (changedExtras) {
          modalMessage += `<p><strong>Дополнительные настройки:</strong></p><ul>${changedExtras}</ul>`;
        }
        modalMessage += `<p>Оригинальный файл:</p>
                         <audio controls src="${audioPlayer.src}"></audio>
                         <button id="resetBaseBtn" type="button">Сбросить все изменения</button>`;
      } else {
        modalMessage = `<p><strong>Нет никаких изменений!</strong></p><p>Оригинальный файл:</p>
                         <audio controls src="${audioPlayer.src}"></audio>`;
      }
      openInfoModal(modalMessage);
      
      if (document.getElementById('resetBaseBtn')) {
        document.getElementById('resetBaseBtn').addEventListener('click', () => {
          let changedBaseReset = "";
          if (parseFloat(volumeControl.value) !== 1) {
            changedBaseReset += `<p><strong>Громкость:</strong> ${volumeControl.value} <button class="reset-single" data-setting="volume">🔁</button></p>`;
          }
          if (parseFloat(delayControl.value) !== 0) {
            changedBaseReset += `<p><strong>Задержка:</strong> ${delayControl.value} сек <button class="reset-single" data-setting="delay">🔁</button></p>`;
          }
          let changedExtrasReset = "";
          for (let i = 0; i < extraEffectsConfig.length; i++) {
            const slider = document.getElementById('extraControl' + i);
            if (slider && parseFloat(slider.value) !== parseFloat(extraEffectsConfig[i].value)) {
              changedExtrasReset += `<li data-extra-index="${i}"><strong>${extraEffectsConfig[i].name}:</strong> ${slider.value} <button class="reset-single" data-extra-index="${i}">🔁</button></li>`;
            }
          }
          volumeControl.value = 1;
          volumeValue.textContent = '1.00';
          delayControl.value = 0;
          delayValue.textContent = '0.00';
          if (gainNode) gainNode.gain.value = 1;
          if (delayNode) delayNode.delayTime.value = 0;
          for (let i = 0; i < extraEffectsConfig.length; i++) {
            const slider = document.getElementById('extraControl' + i);
            if (slider) {
              slider.value = extraEffectsConfig[i].value;
              let display = slider.parentElement.querySelector('.value-display');
              if (display) display.textContent = `Значение: ${extraEffectsConfig[i].value}`;
              slider.dispatchEvent(new Event('input'));
            }
          }
          let resetMessage = "";
          if (changedBaseReset || changedExtrasReset) {
            if (changedBaseReset) {
              resetMessage += `<p><strong>Базовые настройки:</strong></p>` + changedBaseReset;
            }
            if (changedExtrasReset) {
              resetMessage += `<p><strong>Дополнительные настройки:</strong></p><ul>${changedExtrasReset}</ul>`;
            }
          } else {
            resetMessage = `<p><strong>Нет никаких изменений!</strong></p>`;
          }
          resetMessage += `<p>Оригинальный файл:</p>
                           <audio controls src="${audioPlayer.src}"></audio>`;
          openInfoModal(resetMessage);
        });
      }
    });
    
    // Обработчики для кнопок info (data-info)
    document.querySelectorAll('label .info-btn[data-info]').forEach(btn => {
      if (btn.id !== 'baseInfoBtn') {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          openInfoModal(e.target.getAttribute('data-info'));
        });
      }
    });
    
    // Обработка загрузки файла
    audioUpload.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        if (localStorage.getItem('created_musics')){
          localStorage.setItem('created_musics', String(Number(localStorage.getItem('created_musics')) + 1));
        }
        else{
          localStorage.setItem('created_musics', '1');
        }
        originalFileName = file.name;
        audioFile = file;
        const fileURL = URL.createObjectURL(file);
        audioPlayer.src = fileURL;
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        initAudioContext();

        // Скрываем секцию загрузки файла
        document.querySelector('.upload-section').style.display = 'none';

        // Отображаем фон-визуализатор
        const visCanvas = document.getElementById('visualizerBackground');
        visCanvas.style.display = 'block';

        // Создаем анализатор для визуализатора и подключаем его к выходу gainNode
        visualizerAnalyser = audioContext.createAnalyser();
        visualizerAnalyser.fftSize = 256;
        gainNode.connect(visualizerAnalyser);

        // Запускаем анимацию визуализатора
        drawVisualizer();
      }
    });
    
    // Управление базовыми эффектами
    volumeControl.addEventListener('input', () => {
      if (gainNode) {
        gainNode.gain.value = parseFloat(volumeControl.value);
        volumeValue.textContent = parseFloat(volumeControl.value).toFixed(2);
      }
    });
    
    delayControl.addEventListener('input', () => {
      if (delayNode) {
        delayNode.delayTime.value = parseFloat(delayControl.value);
        delayValue.textContent = parseFloat(delayControl.value).toFixed(2);
      }
    });
    
    // Переключение отображения дополнительных настроек
    toggleExtra.addEventListener('click', () => {
      if (!audioPlayer.src) {
        openInfoModal("Файл не выбран.<br>Пожалуйста выберите файл перед тем как прослушать его!");
        return;
      }
      if (extraTools.style.display === "none" || extraTools.style.display === "") {
        extraTools.style.display = "block";
        toggleExtra.textContent = "Свернуть⬆️";
      } else {
        extraTools.style.display = "none";
        toggleExtra.textContent = "Развернуть⬇️";
      }
    });
    
    // Закрытие модального окна ошибки
    closeOverlay.addEventListener('click', () => {
      document.getElementById('overlay').style.display = 'none';
    });
    
    // Инициализация AudioContext – авто-воспроизведение не производится
    function initAudioContext() {
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      audioContext.resume();
      // Аудио-элемент остается muted – звук выводится через AudioContext
      audioPlayer.muted = true;
      
      sourceNode = audioContext.createMediaElementSource(audioPlayer);
      gainNode = audioContext.createGain();
      delayNode = audioContext.createDelay(2.0);
      
      extraEffects = extraEffectsConfig.map(cfg => createExtraEffect(cfg));
      
      sourceNode.connect(gainNode);
      gainNode.connect(delayNode);
      // Если все extra-слайдеры на нейтральном уровне, bypassExtraEffects=true
      bypassExtraEffects = true;
      delayNode.connect(audioContext.destination);
      
      if (!extraControlsGenerated) {
        generateExtraControls();
        extraControlsGenerated = true;
      }
    }
    
    // При клике на native-кнопку Play AudioContext возобновляется (если в suspended)
    audioPlayer.addEventListener('play', () => {
      if (audioContext && audioContext.state !== "running") {
        audioContext.resume();
      }
    });

    /* --- Код визуализатора --- */
    let visualizerCanvas = document.getElementById('visualizerBackground');
    let visualizerCtx = visualizerCanvas.getContext('2d');
    let visualizerAnalyser;
    
    function resizeVisualizer() {
      visualizerCanvas.width = window.innerWidth;
      visualizerCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeVisualizer);
    resizeVisualizer();
    
    function drawVisualizer() {
      requestAnimationFrame(drawVisualizer);
      if (!visualizerAnalyser) return;
      let bufferLength = visualizerAnalyser.frequencyBinCount;
      let dataArray = new Uint8Array(bufferLength);
      visualizerAnalyser.getByteFrequencyData(dataArray);
      visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
      
      let barWidth = (visualizerCanvas.width / bufferLength) * 2.5;
      let barHeight;
      let x = 0;
      
      for (let i = 0; i < bufferLength; i++) {
        barHeight = dataArray[i];
        visualizerCtx.fillStyle = `rgb(${barHeight+100},50,${255-barHeight})`;
        visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
        x += barWidth + 1;
      }
    }
    /* --- Конец кода визуализатора --- */

    // Функция рендеринга обработанного аудио
    async function renderProcessedAudio() {
      if (!audioPlayer.src) return null;
      try {
        const response = await fetch(audioPlayer.src);
        const arrayBuffer = await response.arrayBuffer();
        const originalBuffer = await audioContext.decodeAudioData(arrayBuffer);
        const offlineContext = new OfflineAudioContext(originalBuffer.numberOfChannels, originalBuffer.length, originalBuffer.sampleRate);
        const offlineSource = offlineContext.createBufferSource();
        offlineSource.buffer = originalBuffer;
        const offlineGain = offlineContext.createGain();
        offlineGain.gain.value = gainNode.gain.value;
        const offlineDelay = offlineContext.createDelay(2.0);
        offlineDelay.delayTime.value = delayNode.delayTime.value;
        const offlineExtraEffects = [];
        let playbackRateVal = 1;
        for (let i = 0; i < extraEffectsConfig.length; i++) {
          const slider = document.getElementById(`extraControl${i}`);
          const val = parseFloat(slider.value);
          const cfg = {...extraEffectsConfig[i], value: val};
          if (cfg.type === 'playbackRate') {
            playbackRateVal = val;
          } else {
            const effectData = createExtraEffect(cfg, offlineContext);
            offlineExtraEffects.push(effectData);
          }
        }
        offlineSource.playbackRate.value = playbackRateVal;
        offlineSource.connect(offlineGain);
        offlineGain.connect(offlineDelay);
        let lastNode = offlineDelay;
        if (offlineExtraEffects.length > 0) {
          lastNode.connect(offlineExtraEffects[0].node);
          for (let i = 0; i < offlineExtraEffects.length - 1; i++) {
            offlineExtraEffects[i].node.connect(offlineExtraEffects[i + 1].node);
          }
          offlineExtraEffects[offlineExtraEffects.length - 1].node.connect(offlineContext.destination);
        } else {
          lastNode.connect(offlineContext.destination);
        }
        offlineSource.start(0);
        const renderedBuffer = await offlineContext.startRendering();
        return audioBufferToWav(renderedBuffer);
      } catch (error) {
        console.error(error);
        return null;
      }
    }

    // Функция конвертации AudioBuffer в WAV Blob
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const out = new ArrayBuffer(length);
      const view = new DataView(out);
      writeString(view, 0, 'RIFF');
      view.setUint32(4, length - 8, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, buffer.sampleRate, true);
      view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
      view.setUint16(32, numOfChan * 2, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, buffer.length * numOfChan * 2, true);
      let offset = 44;
      for (let i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }
      return new Blob([out], {type: 'audio/wav'});
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
  </script>
</body>
</html>