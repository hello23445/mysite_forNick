<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Генератор Аватарки</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Raleway&family=Inter&family=Playfair+Display&family=Lato&family=Source+Sans+Pro&display=swap" rel="stylesheet">
  <style>
    /* Общие стили */
    * {
      user-select: none;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #74ABE2, #5563DE);
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .container {
      display: flex;
      width: 90%;
      max-width: 1200px;
      height: 90%;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      border-radius: 12px;
      overflow: hidden;
      background: none;
      position: relative;
    }
    .preview {
      flex: 1;
      background: none;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    #avatarCanvas {
      max-width: 100%;
      max-height: 100%;
      border: 1px solid #ccc;
      background: transparent;
    }
    /* Оверлей для перетаскивания файлов */
    #dragOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 24px;
      font-weight: bold;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .tools {
      width: 350px;
      padding: 20px;
      overflow-y: auto;
      background: #c6ddff;
      position: relative;
      transition: all 0.3s ease;
    }
    #hideToolsButton {
      display: block;
      margin-bottom: 20px;
      padding: 10px 15px;
      background: red;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
    }
    .tools label {
      display: block;
      margin-top: 15px;
      font-weight: bold;
    }
    .tools input[type="range"],
    .tools select,
    .tools input[type="color"],
    .tools input[type="file"],
    .tools textarea {
      width: 100%;
      margin-top: 5px;
      padding: 10px;
      font-size: 16px;
      box-sizing: border-box;
    }
    .tools input[type="color"] {
      height: 40px;
      padding: 0;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow: hidden;
    }
    .tools input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    .tools input[type="color"]::-webkit-color-swatch {
      border: none;
    }
    .tools input[type="color"]::-moz-color-swatch {
      border: none;
    }
    .btn-remove {
      display: inline-block;
      margin-top: 10px;
      padding: 10px;
      background: red;
      color: #fff;
      font-weight: bold;
      border: none;
      cursor: pointer;
    }
    .tools button {
      margin-top: 15px;
      padding: 10px 15px;
      background: blue;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
    }
    .preview.dragover {
      border: 3px dashed #888;
    }
    #mediaSettings {
      margin-top: 15px;
      padding: 10px;
      border: 1px dashed #ccc;
      display: none;
    }
    #orientation-warning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    #orientation-warning div {
      background-color: rgba(50, 50, 50, 0.9);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    #orientation-warning p {
      margin: 0 0 20px;
      color: #fff;
      font-weight: bold;
    }
    #orientation-warning button {
      padding: 10px 20px;
      font-weight: bold;
      cursor: pointer;
      background-color: red;
      color: white;
      border: none;
      border-radius: 5px;
    }
    #openToolsButton {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px 15px;
      background: red;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      display: none;
      z-index: 9999;
    }
    /* Модальное окно для рисования своей формы */
    #customShapeModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      z-index: 20000;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    /* Блок для настройки размера ластика – позиционируется слева от холста */
    #eraserSettings {
      position: absolute;
      left: 20px;
      top: 20px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      display: none;
      z-index: 21000;
    }
    #eraserSettings label {
      font-weight: bold;
      color: #fff;
    }
    #eraserSettings input[type="range"] {
      width: 150px;
      margin-top: 5px;
    }
    #customShapeModal canvas {
      background: #fff;
      border: 2px solid #000;
    }
    #customShapeModal .modal-buttons {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    #customShapeModal button {
      padding: 10px 20px;
      background: green;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
    }
    #customShapeModal button.cancel {
      background: red;
    }
    @media (max-width: 600px) {
      .container {
        flex-direction: column;
        width: 100%;
        height: 100%;
        border-radius: 0;
      }
      .preview {
        width: 100%;
        height: 50vh;
      }
      .tools {
        width: 100%;
        height: 50vh;
      }
      #hideToolsButton {
        padding: 8px 12px;
      }
      #customShapeModal canvas {
        width: 90vw;
        height: 50vh;
      }
      #eraserSettings input[type="range"] {
        width: 100px;
      }
    }
  </style>
</head>
<body>
  
  <!-- Предупреждение об альбомном режиме -->
  <div id="orientation-warning">
    <div>
      <p>Некоторые элементы могут не отображаться в альбомном режиме<br/>Советуем перевернуть ваш телефон в портретный режим.</p>
      <button id="orientation-ok">OK</button>
    </div>
  </div>
  
  <!-- Модальное окно для рисования своей формы -->
  <div id="customShapeModal">
    <div id="eraserSettings">
      <label for="eraserSizeRange">Размер ластика:</label>
      <input type="range" id="eraserSizeRange" min="5" max="250" value="20" />
    </div>
    <canvas id="customShapeCanvas" width="400" height="400"></canvas>
    <div class="modal-buttons">
      <button id="toggleEraser">Ластик</button>
      <button id="resetCustomShape">Сбросить</button>
      <button id="saveCustomShape">Сохранить</button>
      <button id="cancelCustomShape" class="cancel">Отмена</button>
    </div>
  </div>
  
  <div class="container">
    <button id="openToolsButton"><b>ОТКРЫТЬ МЕНЮ ИНСТРУМЕНТОВ</b></button>
    <button 
    onclick="window.location.href = 'main.html'" 
    style="padding: 10px; font-size: 16px; display: none; width: 25%; height: 5vh; margin-top: 5%;"
    id="backToMainMenuButton"
    >
    ВЕРНУТЬСЯ В ГЛАВНОЕ МЕНЮ
  </button>
  
  <div class="preview" id="previewArea">
    <canvas id="avatarCanvas" width="300" height="300"></canvas>
    <div id="dragOverlay">Перетащите сюда фото или файл шрифта<br>Ни в коем случае не скидывайте папки!</div>
  </div>
  
  <div class="tools" id="toolsPanel">
    <button id="hideToolsButton"><b>УБРАТЬ МЕНЮ ИНСТРУМЕНТОВ</b></button>
    <button id="shareAvatar" style="margin-top: 0%;"><b>ПОДЕЛИТЬСЯ АВАТАРКОЙ</b></button>
    <button 
    onclick="window.location.href = 'main.html'" 
    style="padding: 10px 20px; font-size: 16px;"
    >
    ВЕРНУТЬСЯ В ГЛАВНОЕ МЕНЮ
  </button>

      <label for="bgColor"><b>Цвет фона:</b></label>
      <input type="color" id="bgColor" value="#800080" />

      <label for="textColor"><b>Цвет текста:</b></label>
      <input type="color" id="textColor" value="#000000" />

      <label for="borderColor"><b>Цвет границы:</b></label>
      <input type="color" id="borderColor" value="#000000" />

      <label for="borderWidth"><b>Толщина границы:</b></label>
      <input type="range" id="borderWidth" min="0" max="100" value="0" />

      <label for="text"><b>Текст на аватарке:(максимум 10 000 символов) <span id="charCount">0/10 000</span></b></label>
      <textarea id="text" placeholder="Ваш текст..." maxlength="10000"></textarea>

      <label for="fontSelect"><b>Шрифт текста:</b></label>
      <select id="fontSelect">
        <option value="upload">ЗАГРУЗИТЬ СВОЙ ШРИФТ</option>
        <option value="Arial" selected>Arial</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Verdana">Verdana</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Impact">Impact</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Lucida Console">Lucida Console</option>
        <option value="Segoe UI">Segoe UI</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Monospace">Monospace</option>
        <option value="Poppins">Poppins</option>
        <option value="Lobster">Lobster</option>
        <option value="Oswald">Oswald</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
        <option value="Inter">Inter</option>
        <option value="Playfair Display">Playfair Display</option>
        <option value="Lato">Lato</option>
        <option value="Source Sans Pro">Source Sans Pro</option>
      </select>
      <input type="file" id="fontUpload" style="display:none" />
      <button id="fontUploadButton" style="display:none;"><b>ЗАГРУЗИТЬ СВОЙ ШРИФТ</b></button>

      <label for="textSize"><b>Размер текста:</b></label>
      <input type="range" id="textSize" min="0" max="1000" value="50" />

      <label for="textShadow"><b>Тень текста:</b></label>
      <input type="range" id="textShadow" min="0" max="30" value="0" />

      <label for="textRotation"><b>Поворот текста (градусы):</b></label>
      <input type="range" id="textRotation" min="0" max="360" value="0" />

      <label for="textOpacity"><b>Прозрачность текста:</b></label>
      <input type="range" id="textOpacity" min="0" max="1" step="0.01" value="1" />

      <label for="dragTextMode"><b>Свободное перемещение текста:</b></label>
      <input type="checkbox" id="dragTextMode" />

      <label for="shapeSelect"><b>Форма аватарки:</b></label>
      <select id="shapeSelect">
        <option value="circle">Круг</option>
        <option value="square">Квадрат</option>
        <option value="hexagon">Шестиугольник</option>
        <option value="star">Звезда</option>
        <option value="rectangle">Прямоугольник</option>
        <option value="oval">Овал</option>
        <option value="triangle">Треугольник</option>
        <option value="pentagon">Пятиугольник</option>
        <option value="heart">Сердце</option>
        <option value="rhombus">Ромб</option>
        <option value="cloud">Облако</option>
        <option value="arrowRight">Стрелка вправо</option>
        <option value="lightning">Молния</option>
        <option value="octagon">Восьмиугольник</option>
        <option value="cross">Крест</option>
        <option value="trapezoid">Трапеция</option>
        <option value="custom"><b>НАРИСОВАТЬ СВОЮ ФОРМУ</b></option>
      </select>

      <label for="imageUpload"><b>Загрузить фото:</b></label>
      <input type="file" id="imageUpload" />
      <button id="removeImageBtn" class="btn-remove" style="display:none;"><b>УДАЛИТЬ ФОТО</b></button>

      <div id="mediaSettings">
        <label for="alignCheckbox"><b>Выровнять фото:</b></label>
        <input type="checkbox" id="alignCheckbox" />

        <label for="qualitySelect"><b>Качество фото:</b></label>
        <select id="qualitySelect">
          <option value="original">Оригинал</option>
          <option value="144">144p</option>
          <option value="240">240p</option>
          <option value="360">360p</option>
          <option value="480">480p</option>
          <option value="720">720p</option>
          <option value="1080">1080p</option>
          <option value="1440">1440p (2K)</option>
          <option value="2160">2160p (4K)</option>
          <option value="4320">4320p (8K)</option>
        </select>

        <label for="blurRange"><b>Размытие фото:</b></label>
        <input type="range" id="blurRange" min="0" max="40" value="0" />

        <label for="imageRotation"><b>Поворот фото (градусы):</b></label>
        <input type="range" id="imageRotation" min="0" max="360" value="0" />

        <label for="imageOpacity"><b>Прозрачность фото:</b></label>
        <input type="range" id="imageOpacity" min="0" max="1" step="0.01" value="1" />

        <label for="grayscale"><b>Черно-белое фото:</b></label>
        <input type="checkbox" id="grayscale" />
      </div>

    </div>
  </div>

  <script>
    /* ========= 0. Проверка ориентации устройства ========= */
    function checkOrientationWarning() {
      if (window.innerWidth > window.innerHeight) {
        orientationWarning.style.display = 'flex';
      } else {
        orientationWarning.style.display = 'none';
      }
    }
    const orientationWarning = document.getElementById('orientation-warning');
    const orientationOk = document.getElementById('orientation-ok');
    orientationOk.addEventListener('click', () => {
      orientationWarning.style.display = 'none';
    });
    window.addEventListener('load', checkOrientationWarning);
    window.addEventListener('resize', checkOrientationWarning);

    /* ========= 1. Получение элементов ========= */
    const canvas = document.getElementById('avatarCanvas');
    const ctx = canvas.getContext('2d');
    const previewArea = document.getElementById('previewArea');
    const dragOverlay = document.getElementById('dragOverlay');
    const toolsPanel = document.getElementById('toolsPanel');
    const openToolsButton = document.getElementById('openToolsButton');

    const bgColorInput = document.getElementById('bgColor');
    const textColorInput = document.getElementById('textColor');
    const borderColorInput = document.getElementById('borderColor');
    const borderWidthInput = document.getElementById('borderWidth');
    const textInput = document.getElementById('text');
    const fontSelect = document.getElementById('fontSelect');
    const fontUpload = document.getElementById('fontUpload');
    const fontUploadButton = document.getElementById('fontUploadButton');
    const textSizeInput = document.getElementById('textSize');
    const textShadowInput = document.getElementById('textShadow');
    const textRotationInput = document.getElementById('textRotation');
    const textOpacityInput = document.getElementById('textOpacity');
    const dragTextMode = document.getElementById('dragTextMode');
    const shapeSelect = document.getElementById('shapeSelect');
    const imageUpload = document.getElementById('imageUpload');
    const removeImageBtn = document.getElementById('removeImageBtn');
    const hideToolsButton = document.getElementById('hideToolsButton');
    const mediaSettings = document.getElementById('mediaSettings');
    const alignCheckbox = document.getElementById('alignCheckbox');
    const qualitySelect = document.getElementById('qualitySelect');
    const blurRange = document.getElementById('blurRange');
    const imageRotationInput = document.getElementById('imageRotation');
    const imageOpacityInput = document.getElementById('imageOpacity');
    const grayscaleCheckbox = document.getElementById('grayscale');
    const shareAvatarBtn = document.getElementById('shareAvatar');

    /* ========= 2. Переменные для медиа ========= */
    let bgImage = null;

    /* ========= 3. Переменные для пользовательской формы ========= */
    let drawnStrokes = [];
    let currentStroke = [];
    let customShapePoints = null;
    let eraserActive = false;
    let eraserRadius = 20;
    const eraserSizeRange = document.getElementById('eraserSizeRange');
    eraserSizeRange.addEventListener('input', () => {
      eraserRadius = parseInt(eraserSizeRange.value, 10);
    });

    /* ========= Переменные для перетаскивания текста ========= */
    let isDraggingText = false;
    let startDragX = 0;
    let startDragY = 0;
    let dragStartTextX = 0;
    let dragStartTextY = 0;
    let textPosX = 0;
    let textPosY = 0;

    /* ========= 4. Проверка поддержки FontFace ========= */
    window.addEventListener('load', () => {
      if (typeof FontFace === 'undefined') {
        const uploadOpt = document.querySelector('option[value="upload"]');
        uploadOpt.disabled = true;
        uploadOpt.textContent = 'ЗАГРУЗИТЬ ШРИФТ (Не доступно)';
      }
    });

    /* ========= 5. Проверка премиума ========= */
    const isPremium = localStorage.getItem('premium') === 'yes';
    if (!isPremium) {
      const uploadOpt = document.querySelector('#fontSelect option[value="upload"]');
      uploadOpt.disabled = true;
      uploadOpt.textContent += ' (Premium)';
      const customOpt = document.querySelector('#shapeSelect option[value="custom"]');
      customOpt.disabled = true;
      customOpt.textContent += ' (Premium)';
      shareAvatarBtn.disabled = true;
      shareAvatarBtn.textContent += ' (Premium)';
    }

    /* ========= 6. Обработка показа/скрытия панели инструментов ========= */
    hideToolsButton.addEventListener('click', () => {
      toolsPanel.style.display = 'none';
      openToolsButton.style.display = 'block';
      if (localStorage.getItem('created_profiles')) {
        localStorage.setItem('created_profiles', String(Number(localStorage.getItem('created_profiles')) + 1));
      } else {
        localStorage.setItem('created_profiles', '1');
      }
    });
    openToolsButton.addEventListener('click', () => {
      toolsPanel.style.display = 'block';
      openToolsButton.style.display = 'none';
    });

    /* ========= 7. Функция отрисовки аватарки ========= */
    function drawAvatar() {
      const size = Math.min(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
      canvas.width = size;
      canvas.height = size;
      ctx.clearRect(0, 0, size, size);

      ctx.save();
      applyShapeClip(ctx, size, shapeSelect.value);
      ctx.fillStyle = bgColorInput.value;
      ctx.fillRect(0, 0, size, size);

      if (bgImage) {
        drawMedia(bgImage);
      }
      ctx.restore();

      const bw = +borderWidthInput.value;
      if (bw > 0) {
        ctx.save();
        ctx.beginPath();
        if (shapeSelect.value === "circle") {
          ctx.arc(size/2, size/2, size/2 - bw/2, 0, Math.PI*2);
        } else if (shapeSelect.value === "square" || shapeSelect.value === "rectangle") {
          ctx.rect(bw/2, bw/2, size - bw, size - bw);
        } else {
          applyShapeClip(ctx, size, shapeSelect.value);
        }
        ctx.strokeStyle = borderColorInput.value;
        ctx.lineWidth = bw;
        ctx.stroke();
        ctx.restore();
      }

      const txt = textInput.value;
      if (txt.trim() !== "") {
        ctx.save();
        ctx.translate(size/2, size/2);
        ctx.rotate(textRotationInput.value * Math.PI / 180);
        ctx.translate(-size/2, -size/2);
        ctx.globalAlpha = textOpacityInput.value;
        const lines = txt.split("\n");
        ctx.font = `${textSizeInput.value}px ${fontSelect.value}`;
        ctx.fillStyle = textColorInput.value;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = +textShadowInput.value;
        const lineHeight = textSizeInput.value * 1.2;
        const totalHeight = lineHeight * lines.length;
        lines.forEach((line, i) => {
          ctx.fillText(line, size/2 + textPosX, size/2 - totalHeight/2 + lineHeight/2 + i * lineHeight + textPosY);
        });
        ctx.restore();
      }
    }

    /* ========= 8. Функция отрисовки медиа ========= */
    function drawMedia(media) {
      const qualityVal = qualitySelect.value;
      const align = alignCheckbox.checked;
      const blurVal = blurRange.value;

      let mediaWidth, mediaHeight;
      mediaWidth = media.naturalWidth;
      mediaHeight = media.naturalHeight;
      let source = media;
      if (qualityVal !== "original" && !qualitySelect.options[qualitySelect.selectedIndex].disabled) {
        const targetHeight = parseInt(qualityVal, 10);
        const scale = targetHeight / mediaHeight;
        const targetWidth = Math.floor(mediaWidth * scale);
        const offCanvas = document.createElement('canvas');
        offCanvas.width = targetWidth;
        offCanvas.height = targetHeight;
        const offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(media, 0, 0, targetWidth, targetHeight);
        source = offCanvas;
        mediaWidth = targetWidth;
        mediaHeight = targetHeight;
      }
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(imageRotationInput.value * Math.PI / 180);
      ctx.translate(-canvas.width / 2, -canvas.height / 2);
      ctx.globalAlpha = imageOpacityInput.value;
      let filter = '';
      if (grayscaleCheckbox.checked) {
        filter += 'grayscale(100%) ';
      }
      if (blurVal > 0) {
        filter += `blur(${blurVal * 3}px)`;
      }
      ctx.filter = filter.trim();
      const cw = canvas.width;
      const ch = canvas.height;
      if (align) {
        const canvasRatio = cw / ch;
        const mediaRatio = mediaWidth / mediaHeight;
        let sx, sy, sWidth, sHeight;
        if (mediaRatio > canvasRatio) {
          sHeight = mediaHeight;
          sWidth = sHeight * canvasRatio;
          sx = (mediaWidth - sWidth) / 2;
          sy = 0;
        } else {
          sWidth = mediaWidth;
          sHeight = sWidth / canvasRatio;
          sx = 0;
          sy = (mediaHeight - sHeight) / 2;
        }
        ctx.drawImage(source, sx, sy, sWidth, sHeight, 0, 0, cw, ch);
      } else {
        ctx.drawImage(source, 0, 0, cw, ch);
      }
      ctx.restore();
    }

    /* ========= 9. Функция применения клипа по форме ========= */
    function applyShapeClip(ctx, size, shape) {
      ctx.beginPath();
      const center = size / 2;
      switch(shape) {
        case "circle":
          ctx.arc(center, center, center, 0, Math.PI * 2);
          break;
        case "square":
        case "rectangle":
          ctx.rect(0, 0, size, size);
          break;
        case "hexagon":
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "star":
          const outerRadius = center;
          const innerRadius = center * 0.5;
          for (let i = 0; i < 10; i++) {
            const angle = (Math.PI / 5) * i - Math.PI / 2;
            const r = i % 2 === 0 ? outerRadius : innerRadius;
            const x = center + r * Math.cos(angle);
            const y = center + r * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "oval":
          ctx.ellipse(center, center, center, center * 0.8, 0, 0, Math.PI * 2);
          break;
        case "triangle":
          ctx.moveTo(center, 0);
          ctx.lineTo(size, size);
          ctx.lineTo(0, size);
          ctx.closePath();
          break;
        case "pentagon":
          for (let i = 0; i < 5; i++) {
            const angle = Math.PI / 2 + (2 * Math.PI * i) / 5;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "heart":
          ctx.moveTo(center, size * 0.9);
          ctx.bezierCurveTo(
            center + size * 0.5, size * 0.6,
            center + size * 0.5, size * 0.2,
            center, size * 0.35
          );
          ctx.bezierCurveTo(
            center - size * 0.5, size * 0.2,
            center - size * 0.5, size * 0.6,
            center, size * 0.9
          );
          break;
        case "rhombus":
          ctx.moveTo(center, 0);
          ctx.lineTo(size, center);
          ctx.lineTo(center, size);
          ctx.lineTo(0, center);
          ctx.closePath();
          break;
        case "cloud":
          ctx.moveTo(center * 0.2, center);
          ctx.bezierCurveTo(
            center * 0.1, center * 0.6,
            center * 0.5, center * 0.6,
            center * 0.4, center * 0.3
          );
          ctx.bezierCurveTo(
            center * 0.6, center * 0.1,
            center * 1.4, center * 0.1,
            center * 1.6, center * 0.3
          );
          ctx.bezierCurveTo(
            center * 1.8, center * 0.4,
            center * 1.8, center,
            center * 1.6, center
          );
          ctx.bezierCurveTo(
            center * 1.4, center * 1.3,
            center * 0.6, center * 1.3,
            center * 0.4, center
          );
          ctx.closePath();
          break;
        case "arrowRight":
          ctx.moveTo(0, center * 0.5);
          ctx.lineTo(center, center * 0.5);
          ctx.lineTo(center, 0);
          ctx.lineTo(size, center);
          ctx.lineTo(center, size);
          ctx.lineTo(center, center * 1.5);
          ctx.lineTo(0, center * 1.5);
          ctx.closePath();
          break;
        case "lightning":
          ctx.moveTo(center * 0.3, 0);
          ctx.lineTo(center * 0.7, 0);
          ctx.lineTo(center * 0.4, center * 0.6);
          ctx.lineTo(center * 0.8, center * 0.6);
          ctx.lineTo(center * 0.2, size);
          ctx.lineTo(center * 0.6, center * 0.6);
          ctx.lineTo(center * 0.3, center * 0.6);
          ctx.closePath();
          break;
        case "octagon":
          const sides = 8;
          for (let i = 0; i < sides; i++) {
            const angle = (2 * Math.PI / sides) * i - Math.PI / 8;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "cross":
          const arm = size / 3;
          ctx.moveTo(center - arm, center - arm / 3);
          ctx.lineTo(center - arm, center + arm / 3);
          ctx.lineTo(center - arm / 3, center + arm / 3);
          ctx.lineTo(center - arm / 3, center + arm);
          ctx.lineTo(center + arm / 3, center + arm);
          ctx.lineTo(center + arm / 3, center + arm / 3);
          ctx.lineTo(center + arm, center + arm / 3);
          ctx.lineTo(center + arm, center - arm / 3);
          ctx.lineTo(center + arm / 3, center - arm / 3);
          ctx.lineTo(center + arm / 3, center - arm);
          ctx.lineTo(center - arm / 3, center - arm);
          ctx.lineTo(center - arm / 3, center - arm / 3);
          ctx.closePath();
          break;
        case "trapezoid":
          ctx.moveTo(center * 0.5, 0);
          ctx.lineTo(center * 1.5, 0);
          ctx.lineTo(size, size);
          ctx.lineTo(0, size);
          ctx.closePath();
          break;
        case "custom":
          if (customShapePoints && customShapePoints.length > 0) {
            const path = new Path2D();
            path.moveTo(customShapePoints[0][0] * size, customShapePoints[0][1] * size);
            for (let i = 1; i < customShapePoints.length; i++) {
              path.lineTo(customShapePoints[i][0] * size, customShapePoints[i][1] * size);
            }
            path.closePath();
            ctx.clip(path);
            return;
          } else {
            ctx.arc(center, center, center, 0, Math.PI * 2);
          }
          break;
        default:
          ctx.rect(0, 0, size, size);
          break;
      }
      ctx.clip();
    }

    /* ========= 10. Обновление видимости mediaSettings ========= */
    function updateMediaSettingsVisibility() {
      if (bgImage) {
        mediaSettings.style.display = 'block';
        updateQualityOptions();
      } else {
        mediaSettings.style.display = 'none';
      }
    }
    function updateQualityOptions() {
      const options = qualitySelect.options;
      let mediaHeight = 0;
      if (bgImage) {
        mediaHeight = bgImage.naturalHeight;
      }
      for (let i = 0; i < options.length; i++) {
        const opt = options[i];
        if (opt.value === "original") {
          opt.disabled = false;
        } else {
          const targetHeight = parseInt(opt.value);
          opt.disabled = (targetHeight > mediaHeight) || ((!isPremium) && (opt.value === "1440" || opt.value === "2160"));
        }
      }
    }

    /* ========= 11. Загрузка фото ========= */
    imageUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      e.target.value = '';
      if (!file || !file.type.startsWith('image/')) return;
      const img = new Image();
      img.onload = () => {
        bgImage = img;
        removeImageBtn.style.display = 'inline-block';
        drawAvatar();
        updateMediaSettingsVisibility();
      };
      img.src = URL.createObjectURL(file);
    });
    removeImageBtn.addEventListener('click', () => {
      bgImage = null;
      imageUpload.value = '';
      removeImageBtn.style.display = 'none';
      drawAvatar();
      updateMediaSettingsVisibility();
    });

    /* ========= 12. Логика загрузки шрифта ========= */
    fontSelect.addEventListener('change', () => {
      if (fontSelect.value === "upload") {
        fontUploadButton.style.display = 'block';
        fontUpload.click();
        setTimeout(() => {
          fontSelect.value = "Arial";
          drawAvatar();
        }, 0);
      } else {
        fontUploadButton.style.display = 'none';
        drawAvatar();
      }
    });
    fontUploadButton.addEventListener('click', () => {
      fontUpload.click();
    });
    fontUpload.addEventListener('change', (e) => {
      let files = e.target.files;
      if (!files || files.length === 0) return;
      if (files.length > 1) {
        alert("Пожалуйста, загрузите один файл шрифта, а не папку.");
        return;
      }
      let fontFile = null;
      for (let i = 0; i < files.length; i++) {
        if (files[i].name.match(/\.(ttf|otf)$/i)) {
          fontFile = files[i];
          break;
        }
      }
      if (!fontFile) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        const fontData = ev.target.result;
        const fontName = "CustomFont_" + Date.now();
        const fontFace = new FontFace(fontName, fontData);
        fontFace.load().then((loadedFace) => {
          document.fonts.add(loadedFace);
          const option = document.createElement("option");
          option.value = fontName;
          option.textContent = fontName;
          fontSelect.appendChild(option);
          fontSelect.value = fontName;
          drawAvatar();
        }).catch(err => console.error("Ошибка загрузки шрифта:", err));
      };
      reader.readAsArrayBuffer(fontFile);
    });

    /* ========= 13. Перетаскивание медиа и файлов шрифта ========= */
    previewArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      previewArea.classList.add('dragover');
      dragOverlay.style.opacity = "1";
    });
    previewArea.addEventListener('dragleave', () => {
      previewArea.classList.remove('dragover');
      dragOverlay.style.opacity = "0";
    });
    previewArea.addEventListener('drop', (e) => {
      e.preventDefault();
      previewArea.classList.remove('dragover');
      dragOverlay.style.opacity = "0";
      const files = e.dataTransfer.files;
      if (!files || files.length === 0) return;
      if (/\.(ttf|otf)$/i.test(files[0].name)) {
        if (!isPremium) {
          alert("Премиум требуется для загрузки шрифта");
          return;
        }
        if (files.length > 1) {
          alert("Пожалуйста, перетащите один файл шрифта, а не папку.");
          return;
        }
        const file = files[0];
        const reader = new FileReader();
        reader.onload = function(ev) {
          const fontData = ev.target.result;
          const fontName = "CustomFont_" + Date.now();
          const fontFace = new FontFace(fontName, fontData);
          fontFace.load().then((loadedFace) => {
            document.fonts.add(loadedFace);
            const option = document.createElement("option");
            option.value = fontName;
            option.textContent = fontName;
            fontSelect.appendChild(option);
            fontSelect.value = fontName;
            drawAvatar();
          }).catch(err => console.error("Ошибка загрузки шрифта:", err));
        };
        reader.readAsArrayBuffer(file);
        return;
      }
      if (files[0].type.startsWith('image/')) {
        const img = new Image();
        img.onload = () => {
          bgImage = img;
          removeImageBtn.style.display = 'inline-block';
          drawAvatar();
          updateMediaSettingsVisibility();
        };
        img.src = URL.createObjectURL(files[0]);
      }
    });

    /* ========= 14. Изменения для пользовательской формы ========= */
    const customShapeModal = document.getElementById('customShapeModal');
    const customShapeCanvas = document.getElementById('customShapeCanvas');
    const customCtx = customShapeCanvas.getContext('2d');
    const saveCustomShapeBtn = document.getElementById('saveCustomShape');
    const cancelCustomShapeBtn = document.getElementById('cancelCustomShape');
    const eraseCustomShapeBtn = document.getElementById('toggleEraser');
    const resetCustomShapeBtn = document.getElementById('resetCustomShape');

    eraserActive = false;
    eraseCustomShapeBtn.addEventListener('click', () => {
      eraserActive = !eraserActive;
      document.getElementById('eraserSettings').style.display = eraserActive ? 'block' : 'none';
      eraseCustomShapeBtn.textContent = eraserActive ? "Ластик (активен)" : "Ластик";
      customShapeCanvas.style.cursor = eraserActive ? 'none' : 'default';
    });

    resetCustomShapeBtn.addEventListener('click', () => {
      drawnStrokes = [];
      currentStroke = [];
      customCtx.clearRect(0, 0, customShapeCanvas.width, customShapeCanvas.height);
    });

    function redrawCustomShapeCanvas() {
      customCtx.clearRect(0, 0, customShapeCanvas.width, customShapeCanvas.height);
      customCtx.beginPath();
      drawnStrokes.forEach(stroke => {
        if (stroke.length > 0) {
          customCtx.moveTo(stroke[0][0], stroke[0][1]);
          for (let i = 1; i < stroke.length; i++) {
            customCtx.lineTo(stroke[i][0], stroke[i][1]);
          }
        }
      });
      if (currentStroke.length > 0) {
        customCtx.moveTo(currentStroke[0][0], currentStroke[0][1]);
        for (let i = 1; i < currentStroke.length; i++) {
          customCtx.lineTo(currentStroke[i][0], currentStroke[i][1]);
        }
      }
      customCtx.strokeStyle = 'black';
      customCtx.lineWidth = 2;
      customCtx.stroke();
    }

    function eraseAtPoint(x, y) {
      const newStrokes = [];
      drawnStrokes.forEach(stroke => {
        let subStroke = [];
        stroke.forEach(pt => {
          const dx = pt[0] - x;
          const dy = pt[1] - y;
          if (Math.sqrt(dx * dx + dy * dy) > eraserRadius) {
            subStroke.push(pt);
          } else {
            if (subStroke.length > 0) {
              newStrokes.push(subStroke);
              subStroke = [];
            }
          }
        });
        if (subStroke.length > 0) {
          newStrokes.push(subStroke);
        }
      });
      drawnStrokes = newStrokes;
      currentStroke = currentStroke.filter(pt => {
        const dx = pt[0] - x;
        const dy = pt[1] - y;
        return Math.sqrt(dx * dx + dy * dy) > eraserRadius;
      });
      redrawCustomShapeCanvas();
      drawEraserIndicator(x, y);
    }

    function drawEraserIndicator(x, y) {
      customCtx.save();
      customCtx.beginPath();
      customCtx.arc(x, y, eraserRadius, 0, 2 * Math.PI);
      customCtx.strokeStyle = 'red';
      customCtx.lineWidth = 1;
      customCtx.setLineDash([4, 2]);
      customCtx.stroke();
      customCtx.restore();
    }

    customShapeCanvas.addEventListener('mousedown', (e) => {
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke = [];
        currentStroke.push([x, y]);
      }
    });
    customShapeCanvas.addEventListener('mousemove', (e) => {
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (eraserActive) {
        if (e.buttons === 1) {
          eraseAtPoint(x, y);
        } else {
          redrawCustomShapeCanvas();
          drawEraserIndicator(x, y);
        }
      } else {
        if (e.buttons !== 1) return;
        currentStroke.push([x, y]);
        redrawCustomShapeCanvas();
      }
    });
    customShapeCanvas.addEventListener('mouseup', () => {
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });
    customShapeCanvas.addEventListener('mouseleave', () => {
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });

    customShapeCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke = [];
        currentStroke.push([x, y]);
      }
    });
    customShapeCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke.push([x, y]);
        redrawCustomShapeCanvas();
      }
    });
    customShapeCanvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });

    saveCustomShapeBtn.addEventListener('click', () => {
      let combinedPoints = [];
      drawnStrokes.forEach(stroke => {
        combinedPoints = combinedPoints.concat(stroke);
      });
      if (combinedPoints.length > 1) {
        customShapePoints = combinedPoints.map(pt => [pt[0] / customShapeCanvas.width, pt[1] / customShapeCanvas.height]);
      }
      customShapeModal.style.display = 'none';
      drawAvatar();
    });
    cancelCustomShapeBtn.addEventListener('click', () => {
      customShapeModal.style.display = 'none';
      shapeSelect.value = 'circle';
      drawAvatar();
    });
    shapeSelect.addEventListener('change', () => {
      if (shapeSelect.value === 'custom') {
        customShapeModal.style.display = 'flex';
      }
      drawAvatar();
    });

    /* ========= 15. Кнопка поделиться ========= */
    shareAvatarBtn.addEventListener('click', () => {
      canvas.toBlob(blob => {
        const file = new File([blob], 'avatar.png', { type: 'image/png' });
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          navigator.share({
            files: [file],
            title: 'Моя аватарка',
            text: 'Смотри, какую аватарку я создал!'
          }).catch(console.error);
        } else {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'avatar.png';
          a.click();
        }
      });
    });

    /* ========= 16. Привязка событий для остальных полей ========= */
    const allInputs = document.querySelectorAll('.tools input, .tools select, .tools textarea');
    allInputs.forEach(el => {
      el.addEventListener('input', drawAvatar);
      el.addEventListener('change', drawAvatar);
    });
    
    function formatNumber(n) {
      return n.toLocaleString('ru-RU');
    }
    function updateCharCount() {
      document.getElementById('charCount').textContent = formatNumber(textInput.value.length) + "/" + formatNumber(10000);
    }
    textInput.addEventListener('input', updateCharCount);

    let cursorX = 0;
    let cursorY = 0;
    let isHoveringCanvas = false;
    canvas.addEventListener('mousemove', e => {
      isHoveringCanvas = true;
      const rect = canvas.getBoundingClientRect();
      cursorX = e.clientX - rect.left;
      cursorY = e.clientY - rect.top;
    });
    canvas.addEventListener('mouseleave', () => {
      isHoveringCanvas = false;
    });
    bgColorInput.addEventListener('input', () => {
      drawAvatar();
      if (isHoveringCanvas) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(cursorX, cursorY, 20, 0, 2 * Math.PI);
        ctx.fillStyle = bgColorInput.value;
        ctx.fill();
        ctx.restore();
      }
    });

    /* ========= Логика перетаскивания текста ========= */
    function handleMouseDown(e) {
      if (!dragTextMode.checked) return;
      isDraggingText = true;
      const rect = canvas.getBoundingClientRect();
      startDragX = e.clientX - rect.left;
      startDragY = e.clientY - rect.top;
      dragStartTextX = textPosX;
      dragStartTextY = textPosY;
    }

    function handleMouseMove(e) {
      if (!isDraggingText || !dragTextMode.checked) return;
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      textPosX = dragStartTextX + (currentX - startDragX);
      textPosY = dragStartTextY + (currentY - startDragY);
      drawAvatar();
    }

    function handleMouseUp() {
      isDraggingText = false;
    }

    function handleTouchStart(e) {
      if (!dragTextMode.checked) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      startDragX = touch.clientX - rect.left;
      startDragY = touch.clientY - rect.top;
      dragStartTextX = textPosX;
      dragStartTextY = textPosY;
      isDraggingText = true;
    }

    function handleTouchMove(e) {
      if (!isDraggingText || !dragTextMode.checked) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const currentX = touch.clientX - rect.left;
      const currentY = touch.clientY - rect.top;
      textPosX = dragStartTextX + (currentX - startDragX);
      textPosY = dragStartTextY + (currentY - startDragY);
      drawAvatar();
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      isDraggingText = false;
    }

    function enableTextDragging() {
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('mouseleave', handleMouseUp);
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      canvas.style.cursor = 'move';
    }

    function disableTextDragging() {
      canvas.removeEventListener('mousedown', handleMouseDown);
      canvas.removeEventListener('mousemove', handleMouseMove);
      canvas.removeEventListener('mouseup', handleMouseUp);
      canvas.removeEventListener('mouseleave', handleMouseUp);
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchmove', handleTouchMove);
      canvas.removeEventListener('touchend', handleTouchEnd);
      canvas.style.cursor = 'default';
    }

    dragTextMode.addEventListener('change', () => {
      if (dragTextMode.checked) {
        enableTextDragging();
      } else {
        disableTextDragging();
      }
    });

    /* ========= 17. Инициализация ========= */
    updateMediaSettingsVisibility();
    drawAvatar();
    if (document.getElementById('shareAvatar').disabled === true) {
      document.getElementById('shareAvatar').style.background = 'gray';
    }
  </script>
</body>
</html>