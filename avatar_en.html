<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Avatar Generator</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Raleway&family=Inter&family=Playfair+Display&family=Lato&family=Source+Sans+Pro&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <style>
    /* General styles */
    * {
      user-select: none;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #74ABE2, #5563DE);
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }
    .container {
      display: flex;
      width: 90%;
      max-width: 1200px;
      height: 90%;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      border-radius: 12px;
      overflow: hidden;
      background: none;
      position: relative;
    }
    .preview {
      flex: 1;
      background: none;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    #avatarCanvas {
      max-width: 100%;
      max-height: 100%;
      border: 1px solid #ccc;
      background: transparent;
    }
    /* Overlay for dragging files */
    #dragOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 24px;
      font-weight: bold;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .tools {
      width: 350px;
      padding: 20px;
      overflow-y: auto;
      background: #c6ddff;
      position: relative;
      transition: all 0.3s ease;
    }
    #hideToolsButton {
      display: block;
      margin-bottom: 20px;
      padding: 10px 15px;
      background: red;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
    }
    .tools label {
      display: block;
      margin-top: 15px;
      font-weight: bold;
    }
    .tools input[type="range"],
    .tools select,
    .tools input[type="color"],
    .tools input[type="file"],
    .tools textarea {
      width: 100%;
      margin-top: 5px;
      padding: 10px;
      font-size: 16px;
      box-sizing: border-box;
    }
    .tools input[type="color"] {
      height: 40px;
      padding: 0;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow: hidden;
    }
    .tools input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    .tools input[type="color"]::-webkit-color-swatch {
      border: none;
    }
    .tools input[type="color"]::-moz-color-swatch {
      border: none;
    }
    .btn-remove {
      display: inline-block;
      margin-top: 10px;
      padding: 10px;
      background: red;
      color: #fff;
      font-weight: bold;
      border: none;
      cursor: pointer;
    }
    .tools button {
      margin-top: 15px;
      padding: 10px 15px;
      background: blue;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
    }
    .preview.dragover {
      border: 3px dashed #888;
    }
    #mediaSettings {
      margin-top: 15px;
      padding: 10px;
      border: 1px dashed #ccc;
      display: none;
    }
    #orientation-warning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    #orientation-warning div {
      background-color: rgba(50, 50, 50, 0.9);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    #orientation-warning p {
      margin: 0 0 20px;
      color: #fff;
      font-weight: bold;
    }
    #orientation-warning button {
      padding: 10px 20px;
      font-weight: bold;
      cursor: pointer;
      background-color: red;
      color: white;
      border: none;
      border-radius: 5px;
    }
    #openToolsButton {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px 15px;
      background: red;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      display: none;
      z-index: 9999;
    }
    /* Modal window for drawing custom shape */
    #customShapeModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      z-index: 20000;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    /* Block for eraser size settings â€“ positioned to the left of the canvas */
    #eraserSettings {
      position: absolute;
      left: 20px;
      top: 20px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      display: none;
      z-index: 21000;
    }
    #eraserSettings label {
      font-weight: bold;
      color: #fff;
    }
    #eraserSettings input[type="range"] {
      width: 150px;
      margin-top: 5px;
    }
    #customShapeModal canvas {
      background: #fff;
      border: 2px solid #000;
    }
    #customShapeModal .modal-buttons {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    #customShapeModal button {
      padding: 10px 20px;
      background: green;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
    }
    #customShapeModal button.cancel {
      background: red;
    }
    @media (max-width: 600px) {
      .container {
        flex-direction: column;
        width: 100%;
        height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        border-radius: 0;
        overflow: hidden;
      }
      .preview {
        width: 100%;
        height: 40vh;
        min-height: 200px;
      }
      .tools {
        width: 100%;
        /* tools fill remaining viewport under preview and respect safe areas */
        height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 40vh - 16px);
        position: relative;
        overflow-y: auto;
        box-sizing: border-box;
        padding-bottom: env(safe-area-inset-bottom);
      }
      #openToolsButton { display: block; }
      #hideToolsButton {
        padding: 8px 12px;
      }
      #customShapeModal canvas {
        width: 90vw;
        height: 50vh;
      }
      #eraserSettings input[type="range"] {
        width: 100px;
      }
    }
  </style>
</head>
<body>

  <!-- orientation warning removed -->

  <!-- Modal window for drawing custom shape -->
  <div id="customShapeModal">
    <div id="eraserSettings">
      <label for="eraserSizeRange">Eraser Size:</label>
      <input type="range" id="eraserSizeRange" min="5" max="250" value="20" />
    </div>
    <canvas id="customShapeCanvas" width="400" height="400"></canvas>
    <div class="modal-buttons">
      <button id="toggleEraser">Eraser</button>
      <button id="resetCustomShape">Reset</button>
      <button id="saveCustomShape">Save</button>
      <button id="cancelCustomShape" class="cancel">Cancel</button>
    </div>
  </div>

  <div class="container">
    <button id="openToolsButton" style="display: none;"><b>OPEN TOOLS MENU</b></button>
    <button 
    onclick="window.location.href = 'main.html'" 
    style="padding: 10px; font-size: 16px; display: none; width: 25%; height: 5vh; margin-top: 5%;"
    id="backToMainMenuButton"
    >
    RETURN TO MAIN MENU
    </button>

    <div class="preview" id="previewArea">
      <canvas id="avatarCanvas" width="300" height="300"></canvas>
      <div id="dragOverlay">Drag a photo or font file here<br>Do not drop folders!</div>
    </div>

    <div class="tools" id="toolsPanel">
      <button id="hideToolsButton"><b>HIDE TOOLS MENU</b></button>
      <button id="shareAvatar" style="margin-top: 0%;"><b>SHARE AVATAR</b></button>
      <button 
        onclick="window.location.href = 'main.html'" 
        style="padding: 10px 20px; font-size: 16px;"
      >
        RETURN TO MAIN MENU
      </button>

      <label for="bgColor"><b>Background Color:</b></label>
      <input type="color" id="bgColor" value="#800080" />

      <label for="textColor"><b>Text Color:</b></label>
      <input type="color" id="textColor" value="#000000" />

      <label for="borderColor"><b>Border Color:</b></label>
      <input type="color" id="borderColor" value="#000000" />

      <label for="borderWidth"><b>Border Thickness:</b></label>
      <input type="range" id="borderWidth" min="0" max="100" value="0" />

      <label for="text"><b>Text on Avatar: (maximum 10,000 characters) <span id="charCount">0/10,000</span></b></label>
      <textarea id="text" placeholder="Your text..." maxlength="10000"></textarea>

      <label for="fontSelect"><b>Text Font:</b></label>
      <select id="fontSelect">
        <option value="upload">UPLOAD YOUR FONT</option>
        <option value="Arial" selected>Arial</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Verdana">Verdana</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Impact">Impact</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Lucida Console">Lucida Console</option>
        <option value="Segoe UI">Segoe UI</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Monospace">Monospace</option>
        <option value="Poppins">Poppins</option>
        <option value="Lobster">Lobster</option>
        <option value="Oswald">Oswald</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
        <option value="Inter">Inter</option>
        <option value="Playfair Display">Playfair Display</option>
        <option value="Lato">Lato</option>
        <option value="Source Sans Pro">Source Sans Pro</option>
      </select>
      <input type="file" id="fontUpload" style="display:none" />
      <button id="fontUploadButton" style="display:none;"><b>UPLOAD YOUR FONT</b></button>

      <label for="textSize"><b>Text Size:</b></label>
      <input type="range" id="textSize" min="0" max="1000" value="50" />

      <label for="textShadow"><b>Text Shadow:</b></label>
      <input type="range" id="textShadow" min="0" max="30" value="0" />

      <label for="textRotation"><b>Text Rotation (degrees):</b></label>
      <input type="range" id="textRotation" min="0" max="360" value="0" />

      <label for="textOpacity"><b>Text Opacity:</b></label>
      <input type="range" id="textOpacity" min="0" max="1" step="0.01" value="1" />

      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="dragTextMode"><b>Free Text Movement:</b></label>
        <div class="toggle-icon" id="dragTextMode" data-checked="false"><i class="fa-solid fa-toggle-off"></i></div>
      </div>

      <label for="shapeSelect"><b>Avatar Shape:</b></label>
      <select id="shapeSelect">
        <option value="circle">Circle</option>
        <option value="square">Square</option>
        <option value="hexagon">Hexagon</option>
        <option value="star">Star</option>
        <option value="rectangle">Rectangle</option>
        <option value="oval">Oval</option>
        <option value="triangle">Triangle</option>
        <option value="pentagon">Pentagon</option>
        <option value="heart">Heart</option>
        <option value="rhombus">Rhombus</option>
        <option value="cloud">Cloud</option>
        <option value="arrowRight">Arrow Right</option>
        <option value="lightning">Lightning</option>
        <option value="octagon">Octagon</option>
        <option value="cross">Cross</option>
        <option value="trapezoid">Trapezoid</option>
        <option value="custom"><b>DRAW YOUR OWN SHAPE</b></option>
      </select>

      <label for="imageUpload"><b>Upload Photo:</b></label>
      <input type="file" id="imageUpload" />
      <button id="removeImageBtn" class="btn-remove" style="display:none;"><b>REMOVE PHOTO</b></button>

      <div id="mediaSettings">
        <div style="display:flex; align-items:center; justify-content:space-between;">
          <label for="alignCheckbox"><b>Align Photo:</b></label>
          <div class="toggle-icon" id="alignCheckbox" data-checked="false"><i class="fa-solid fa-toggle-off"></i></div>
        </div>

        <label for="qualitySelect"><b>Photo Quality:</b></label>
        <select id="qualitySelect">
          <option value="original">Original</option>
          <option value="144">144p</option>
          <option value="240">240p</option>
          <option value="360">360p</option>
          <option value="480">480p</option>
          <option value="720">720p</option>
          <option value="1080">1080p</option>
          <option value="1440">1440p (2K)</option>
          <option value="2160">2160p (4K)</option>
          <option value="4320">4320p (8K)</option>
        </select>

        <label for="blurRange"><b>Photo Blur:</b></label>
        <input type="range" id="blurRange" min="0" max="40" value="0" />

        <label for="imageRotation"><b>Photo Rotation (degrees):</b></label>
        <input type="range" id="imageRotation" min="0" max="360" value="0" />

        <label for="imageOpacity"><b>Photo Opacity:</b></label>
        <input type="range" id="imageOpacity" min="0" max="1" step="0.01" value="1" />

        <div style="display:flex; align-items:center; justify-content:space-between;">
          <label for="grayscale"><b>Grayscale Photo:</b></label>
          <div class="toggle-icon" id="grayscale" data-checked="false"><i class="fa-solid fa-toggle-off"></i></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Function to show alerts as modal windows
    function showModal(message) {
        let errorModal = document.getElementById('modal-alert');
        let errorMessage = document.getElementById('modal-alert-message');
        let errorOkBtn = document.getElementById('modal-alert-ok');
        
        // If modal doesn't exist - create it
        if (!errorModal) {
            const style = document.createElement('style');
            style.textContent = `
                #modal-alert {
                    display: none;
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                }
                #modal-alert.show {
                    display: flex;
                }
                #modal-alert-content {
                    background: linear-gradient(180deg, #0d0870, #0b0862);
                    padding: 25px;
                    border-radius: 16px;
                    text-align: center;
                    max-width: 400px;
                    width: 90%;
                    border: 1px solid #5f57ff;
                    box-shadow: 0 0 30px rgba(95,87,255,0.3);
                }
                #modal-alert-message {
                    color: #e0e0ff;
                    margin-bottom: 20px;
                    word-wrap: break-word;
                }
                #modal-alert-ok {
                    background: linear-gradient(180deg, #251897, #1b1280);
                    color: #d9d9d9;
                    border: 1px solid rgba(255,255,255,0.08);
                    padding: 10px 20px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-size: 1rem;
                    font-weight: 600;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
                }

            `;
            document.head.appendChild(style);
            
            const modalHtml = `
                <div id="modal-alert" class="show">
                    <div id="modal-alert-content">
                        <p id="modal-alert-message"></p>
                        <button id="modal-alert-ok">OK</button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            errorModal = document.getElementById('modal-alert');
            errorMessage = document.getElementById('modal-alert-message');
            errorOkBtn = document.getElementById('modal-alert-ok');
        }
        
        // Show modal
        errorMessage.textContent = message;
        errorModal.classList.add('show');
        
        errorOkBtn.onclick = () => {
            errorModal.classList.remove('show');
        };
    }
      // Bad-words check (English page)
      const globalBadWordsEn = ['fuck','fucking','bitch','asshole','bastard','dick','cock','pussy','shit','slut','whore','cunt','motherfucker','nigger','nigga','retard','stupid','idiot','dumbass','loser','jerk','gay','fag','faggot','porn','hate'];
      function containsBadWordsLocal(text) {
        if (!text) return false;
        const lower = text.toLowerCase();
        return globalBadWordsEn.some(word => lower.includes(word));
      }
      document.querySelectorAll('input, textarea').forEach(el => {
        el.addEventListener('blur', () => {
          try {
            if (containsBadWordsLocal(el.value || '')) {
              showModal('Field contains inappropriate words.');
              el.value = '';
              try { if (typeof drawAvatar === 'function') drawAvatar(); } catch(e) {}
            }
          } catch (e) {}
        });
      });
    
    /* orientation warning removed */

    /* ========= 1. Getting elements ========= */
    const canvas = document.getElementById('avatarCanvas');
    const ctx = canvas.getContext('2d');
    const previewArea = document.getElementById('previewArea');
    const dragOverlay = document.getElementById('dragOverlay');
    const toolsPanel = document.getElementById('toolsPanel');
    const openToolsButton = document.getElementById('openToolsButton');

    const bgColorInput = document.getElementById('bgColor');
    const textColorInput = document.getElementById('textColor');
    const borderColorInput = document.getElementById('borderColor');
    const borderWidthInput = document.getElementById('borderWidth');
    const textInput = document.getElementById('text');
    const fontSelect = document.getElementById('fontSelect');
    const fontUpload = document.getElementById('fontUpload');
    const fontUploadButton = document.getElementById('fontUploadButton');
    const textSizeInput = document.getElementById('textSize');
    const textShadowInput = document.getElementById('textShadow');
    const textRotationInput = document.getElementById('textRotation');
    const textOpacityInput = document.getElementById('textOpacity');
    const dragTextMode = document.getElementById('dragTextMode');
    const shapeSelect = document.getElementById('shapeSelect');
    const imageUpload = document.getElementById('imageUpload');
    const removeImageBtn = document.getElementById('removeImageBtn');
    const hideToolsButton = document.getElementById('hideToolsButton');
    const mediaSettings = document.getElementById('mediaSettings');
    const alignCheckbox = document.getElementById('alignCheckbox');
    const qualitySelect = document.getElementById('qualitySelect');
    const blurRange = document.getElementById('blurRange');
    const imageRotationInput = document.getElementById('imageRotation');
    const imageOpacityInput = document.getElementById('imageOpacity');
    const grayscaleCheckbox = document.getElementById('grayscale');
    const shareAvatarBtn = document.getElementById('shareAvatar');

    /* ========= 2. Variables for media ========= */
    let bgImage = null;

    /* ========= 3. Variables for custom shape ========= */
    let drawnStrokes = [];
    let currentStroke = [];
    let customShapePoints = null;
    let eraserActive = false;
    let eraserRadius = 20;
    const eraserSizeRange = document.getElementById('eraserSizeRange');
    eraserSizeRange.addEventListener('input', () => {
      eraserRadius = parseInt(eraserSizeRange.value, 10);
    });

    /* ========= Variables for text dragging ========= */
    let isDraggingText = false;
    let startDragX = 0;
    let startDragY = 0;
    let dragStartTextX = 0;
    let dragStartTextY = 0;
    let textPosX = 0;
    let textPosY = 0;

    /* ========= 4. Check FontFace support ========= */
    window.addEventListener('load', () => {
      if (typeof FontFace === 'undefined') {
        const uploadOpt = document.querySelector('option[value="upload"]');
        uploadOpt.disabled = true;
        uploadOpt.textContent = 'UPLOAD FONT (Not available)';
      }
    });

    /* ========= 5. Check premium ========= */
    const isPremium = localStorage.getItem('premium') === 'yes';
    if (!isPremium) {
      const uploadOpt = document.querySelector('#fontSelect option[value="upload"]');
      uploadOpt.disabled = true;
      uploadOpt.textContent += ' (Premium)';
      const customOpt = document.querySelector('#shapeSelect option[value="custom"]');
      customOpt.disabled = true;
      customOpt.textContent += ' (Premium)';
      shareAvatarBtn.disabled = true;
      shareAvatarBtn.textContent += ' (Premium)';
    }

    /* ========= 6. Handling show/hide tools panel ========= */
    hideToolsButton.addEventListener('click', () => {
      toolsPanel.style.display = 'none';
      openToolsButton.style.display = 'block';
      if (localStorage.getItem('created_profiles')) {
        localStorage.setItem('created_profiles', String(Number(localStorage.getItem('created_profiles')) + 1));
      } else {
        localStorage.setItem('created_profiles', '1');
      }
    });
    openToolsButton.addEventListener('click', () => {
      toolsPanel.style.display = 'block';
      openToolsButton.style.display = 'none';
    });

    /* ========= 7. Function to draw avatar ========= */
    function drawAvatar() {
      const size = Math.min(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
      canvas.width = size;
      canvas.height = size;
      ctx.clearRect(0, 0, size, size);

      ctx.save();
      applyShapeClip(ctx, size, shapeSelect.value);
      ctx.fillStyle = bgColorInput.value;
      ctx.fillRect(0, 0, size, size);

      if (bgImage) {
        drawMedia(bgImage);
      }
      ctx.restore();

      const bw = +borderWidthInput.value;
      if (bw > 0) {
        ctx.save();
        ctx.beginPath();
        if (shapeSelect.value === "circle") {
          ctx.arc(size/2, size/2, size/2 - bw/2, 0, Math.PI*2);
        } else if (shapeSelect.value === "square" || shapeSelect.value === "rectangle") {
          ctx.rect(bw/2, bw/2, size - bw, size - bw);
        } else {
          applyShapeClip(ctx, size, shapeSelect.value);
        }
        ctx.strokeStyle = borderColorInput.value;
        ctx.lineWidth = bw;
        ctx.stroke();
        ctx.restore();
      }

      const txt = textInput.value;
      if (txt.trim() !== "") {
        ctx.save();
        ctx.translate(size/2, size/2);
        ctx.rotate(textRotationInput.value * Math.PI / 180);
        ctx.translate(-size/2, -size/2);
        ctx.globalAlpha = textOpacityInput.value;
        const lines = txt.split("\n");
        ctx.font = `${textSizeInput.value}px ${fontSelect.value}`;
        ctx.fillStyle = textColorInput.value;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = +textShadowInput.value;
        const lineHeight = textSizeInput.value * 1.2;
        const totalHeight = lineHeight * lines.length;
        lines.forEach((line, i) => {
          ctx.fillText(line, size/2 + textPosX, size/2 - totalHeight/2 + lineHeight/2 + i * lineHeight + textPosY);
        });
        ctx.restore();
      }
    }

    /* ========= 8. Function to draw media ========= */
    function drawMedia(media) {
      const qualityVal = qualitySelect.value;
      const align = alignCheckbox.getAttribute('data-checked') === 'true';
      const blurVal = blurRange.value;

      let mediaWidth, mediaHeight;
      mediaWidth = media.naturalWidth;
      mediaHeight = media.naturalHeight;
      let source = media;
      if (qualityVal !== "original" && !qualitySelect.options[qualitySelect.selectedIndex].disabled) {
        const targetHeight = parseInt(qualityVal, 10);
        const scale = targetHeight / mediaHeight;
        const targetWidth = Math.floor(mediaWidth * scale);
        const offCanvas = document.createElement('canvas');
        offCanvas.width = targetWidth;
        offCanvas.height = targetHeight;
        const offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(media, 0, 0, targetWidth, targetHeight);
        source = offCanvas;
        mediaWidth = targetWidth;
        mediaHeight = targetHeight;
      }
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(imageRotationInput.value * Math.PI / 180);
      ctx.translate(-canvas.width / 2, -canvas.height / 2);
      ctx.globalAlpha = imageOpacityInput.value;
      let filter = '';
      if (grayscaleCheckbox.getAttribute('data-checked') === 'true') {
        filter += 'grayscale(100%) ';
      }
      if (blurVal > 0) {
        filter += `blur(${blurVal * 3}px)`;
      }
      ctx.filter = filter.trim();
      const cw = canvas.width;
      const ch = canvas.height;
      if (align) {
        const canvasRatio = cw / ch;
        const mediaRatio = mediaWidth / mediaHeight;
        let sx, sy, sWidth, sHeight;
        if (mediaRatio > canvasRatio) {
          sHeight = mediaHeight;
          sWidth = sHeight * canvasRatio;
          sx = (mediaWidth - sWidth) / 2;
          sy = 0;
        } else {
          sWidth = mediaWidth;
          sHeight = sWidth / canvasRatio;
          sx = 0;
          sy = (mediaHeight - sHeight) / 2;
        }
        ctx.drawImage(source, sx, sy, sWidth, sHeight, 0, 0, cw, ch);
      } else {
        ctx.drawImage(source, 0, 0, cw, ch);
      }
      ctx.restore();
    }

    /* ========= 9. Function to apply shape clip ========= */
    function applyShapeClip(ctx, size, shape) {
      ctx.beginPath();
      const center = size / 2;
      switch(shape) {
        case "circle":
          ctx.arc(center, center, center, 0, Math.PI * 2);
          break;
        case "square":
        case "rectangle":
          ctx.rect(0, 0, size, size);
          break;
        case "hexagon":
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "star":
          const outerRadius = center;
          const innerRadius = center * 0.5;
          for (let i = 0; i < 10; i++) {
            const angle = (Math.PI / 5) * i - Math.PI / 2;
            const r = i % 2 === 0 ? outerRadius : innerRadius;
            const x = center + r * Math.cos(angle);
            const y = center + r * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "oval":
          ctx.ellipse(center, center, center, center * 0.8, 0, 0, Math.PI * 2);
          break;
        case "triangle":
          ctx.moveTo(center, 0);
          ctx.lineTo(size, size);
          ctx.lineTo(0, size);
          ctx.closePath();
          break;
        case "pentagon":
          for (let i = 0; i < 5; i++) {
            const angle = Math.PI / 2 + (2 * Math.PI * i) / 5;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "heart":
          ctx.moveTo(center, size * 0.9);
          ctx.bezierCurveTo(
            center + size * 0.5, size * 0.6,
            center + size * 0.5, size * 0.2,
            center, size * 0.35
          );
          ctx.bezierCurveTo(
            center - size * 0.5, size * 0.2,
            center - size * 0.5, size * 0.6,
            center, size * 0.9
          );
          break;
        case "rhombus":
          ctx.moveTo(center, 0);
          ctx.lineTo(size, center);
          ctx.lineTo(center, size);
          ctx.lineTo(0, center);
          ctx.closePath();
          break;
        case "cloud":
          ctx.moveTo(center * 0.2, center);
          ctx.bezierCurveTo(
            center * 0.1, center * 0.6,
            center * 0.5, center * 0.6,
            center * 0.4, center * 0.3
          );
          ctx.bezierCurveTo(
            center * 0.6, center * 0.1,
            center * 1.4, center * 0.1,
            center * 1.6, center * 0.3
          );
          ctx.bezierCurveTo(
            center * 1.8, center * 0.4,
            center * 1.8, center,
            center * 1.6, center
          );
          ctx.bezierCurveTo(
            center * 1.4, center * 1.3,
            center * 0.6, center * 1.3,
            center * 0.4, center
          );
          ctx.closePath();
          break;
        case "arrowRight":
          ctx.moveTo(0, center * 0.5);
          ctx.lineTo(center, center * 0.5);
          ctx.lineTo(center, 0);
          ctx.lineTo(size, center);
          ctx.lineTo(center, size);
          ctx.lineTo(center, center * 1.5);
          ctx.lineTo(0, center * 1.5);
          ctx.closePath();
          break;
        case "lightning":
          ctx.moveTo(center * 0.3, 0);
          ctx.lineTo(center * 0.7, 0);
          ctx.lineTo(center * 0.4, center * 0.6);
          ctx.lineTo(center * 0.8, center * 0.6);
          ctx.lineTo(center * 0.2, size);
          ctx.lineTo(center * 0.6, center * 0.6);
          ctx.lineTo(center * 0.3, center * 0.6);
          ctx.closePath();
          break;
        case "octagon":
          const sides = 8;
          for (let i = 0; i < sides; i++) {
            const angle = (2 * Math.PI / sides) * i - Math.PI / 8;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "cross":
          const arm = size / 3;
          ctx.moveTo(center - arm, center - arm / 3);
          ctx.lineTo(center - arm, center + arm / 3);
          ctx.lineTo(center - arm / 3, center + arm / 3);
          ctx.lineTo(center - arm / 3, center + arm);
          ctx.lineTo(center + arm / 3, center + arm);
          ctx.lineTo(center + arm / 3, center + arm / 3);
          ctx.lineTo(center + arm, center + arm / 3);
          ctx.lineTo(center + arm, center - arm / 3);
          ctx.lineTo(center + arm / 3, center - arm / 3);
          ctx.lineTo(center + arm / 3, center - arm);
          ctx.lineTo(center - arm / 3, center - arm);
          ctx.lineTo(center - arm / 3, center - arm / 3);
          ctx.closePath();
          break;
        case "trapezoid":
          ctx.moveTo(center * 0.5, 0);
          ctx.lineTo(center * 1.5, 0);
          ctx.lineTo(size, size);
          ctx.lineTo(0, size);
          ctx.closePath();
          break;
        case "custom":
          if (customShapePoints && customShapePoints.length > 0) {
            const path = new Path2D();
            path.moveTo(customShapePoints[0][0] * size, customShapePoints[0][1] * size);
            for (let i = 1; i < customShapePoints.length; i++) {
              path.lineTo(customShapePoints[i][0] * size, customShapePoints[i][1] * size);
            }
            path.closePath();
            ctx.clip(path);
            return;
          } else {
            ctx.arc(center, center, center, 0, Math.PI * 2);
          }
          break;
        default:
          ctx.rect(0, 0, size, size);
          break;
      }
      ctx.clip();
    }

    /* ========= 10. Update mediaSettings visibility ========= */
    function updateMediaSettingsVisibility() {
      if (bgImage) {
        mediaSettings.style.display = 'block';
        updateQualityOptions();
      } else {
        mediaSettings.style.display = 'none';
      }
    }
    function updateQualityOptions() {
      const options = qualitySelect.options;
      let mediaHeight = 0;
      if (bgImage) {
        mediaHeight = bgImage.naturalHeight;
      }
      for (let i = 0; i < options.length; i++) {
        const opt = options[i];
        if (opt.value === "original") {
          opt.disabled = false;
        } else {
          const targetHeight = parseInt(opt.value);
          opt.disabled = (targetHeight > mediaHeight) || ((!isPremium) && (opt.value === "1440" || opt.value === "2160"));
        }
      }
    }

    /* ========= 11. Upload photo ========= */
    imageUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      e.target.value = '';
      if (!file || !file.type.startsWith('image/')) return;
      const img = new Image();
      img.onload = () => {
        bgImage = img;
        removeImageBtn.style.display = 'inline-block';
        drawAvatar();
        updateMediaSettingsVisibility();
      };
      img.src = URL.createObjectURL(file);
    });
    removeImageBtn.addEventListener('click', () => {
      bgImage = null;
      imageUpload.value = '';
      removeImageBtn.style.display = 'none';
      drawAvatar();
      updateMediaSettingsVisibility();
    });

    /* ========= 12. Font upload logic ========= */
    fontSelect.addEventListener('change', () => {
      if (fontSelect.value === "upload") {
        fontUploadButton.style.display = 'block';
        fontUpload.click();
        setTimeout(() => {
          fontSelect.value = "Arial";
          drawAvatar();
        }, 0);
      } else {
        fontUploadButton.style.display = 'none';
        drawAvatar();
      }
    });
    fontUploadButton.addEventListener('click', () => {
      fontUpload.click();
    });
    fontUpload.addEventListener('change', (e) => {
      let files = e.target.files;
      if (!files || files.length === 0) return;
      if (files.length > 1) {
        showModal("Please upload one font file, not a folder.");
        return;
      }
      let fontFile = null;
      for (let i = 0; i < files.length; i++) {
        if (files[i].name.match(/\.(ttf|otf)$/i)) {
          fontFile = files[i];
          break;
        }
      }
      if (!fontFile) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        const fontData = ev.target.result;
        const fontName = "CustomFont_" + Date.now();
        const fontFace = new FontFace(fontName, fontData);
        fontFace.load().then((loadedFace) => {
          document.fonts.add(loadedFace);
          const option = document.createElement("option");
          option.value = fontName;
          option.textContent = fontName;
          fontSelect.appendChild(option);
          fontSelect.value = fontName;
          drawAvatar();
        }).catch(err => console.error("Font loading error:", err));
      };
      reader.readAsArrayBuffer(fontFile);
    });

    /* ========= 13. Dragging media and font files ========= */
    previewArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      previewArea.classList.add('dragover');
      dragOverlay.style.opacity = "1";
    });
    previewArea.addEventListener('dragleave', () => {
      previewArea.classList.remove('dragover');
      dragOverlay.style.opacity = "0";
    });
    previewArea.addEventListener('drop', (e) => {
      e.preventDefault();
      previewArea.classList.remove('dragover');
      dragOverlay.style.opacity = "0";
      const files = e.dataTransfer.files;
      if (!files || files.length === 0) return;
      if (/\.(ttf|otf)$/i.test(files[0].name)) {
        if (!isPremium) {
          showModal("Premium required for font upload");
          return;
        }
        if (files.length > 1) {
          showModal("Please drag one font file, not a folder.");
          return;
        }
        const file = files[0];
        const reader = new FileReader();
        reader.onload = function(ev) {
          const fontData = ev.target.result;
          const fontName = "CustomFont_" + Date.now();
          const fontFace = new FontFace(fontName, fontData);
          fontFace.load().then((loadedFace) => {
            document.fonts.add(loadedFace);
            const option = document.createElement("option");
            option.value = fontName;
            option.textContent = fontName;
            fontSelect.appendChild(option);
            fontSelect.value = fontName;
            drawAvatar();
          }).catch(err => console.error("Font loading error:", err));
        };
        reader.readAsArrayBuffer(file);
        return;
      }
      if (files[0].type.startsWith('image/')) {
        const img = new Image();
        img.onload = () => {
          bgImage = img;
          removeImageBtn.style.display = 'inline-block';
          drawAvatar();
          updateMediaSettingsVisibility();
        };
        img.src = URL.createObjectURL(files[0]);
      }
    });

    /* ========= 14. Changes for custom shape ========= */
    const customShapeModal = document.getElementById('customShapeModal');
    const customShapeCanvas = document.getElementById('customShapeCanvas');
    const customCtx = customShapeCanvas.getContext('2d');
    const saveCustomShapeBtn = document.getElementById('saveCustomShape');
    const cancelCustomShapeBtn = document.getElementById('cancelCustomShape');
    const eraseCustomShapeBtn = document.getElementById('toggleEraser');
    const resetCustomShapeBtn = document.getElementById('resetCustomShape');

    eraserActive = false;
    eraseCustomShapeBtn.addEventListener('click', () => {
      eraserActive = !eraserActive;
      document.getElementById('eraserSettings').style.display = eraserActive ? 'block' : 'none';
      eraseCustomShapeBtn.textContent = eraserActive ? "Eraser (active)" : "Eraser";
      customShapeCanvas.style.cursor = eraserActive ? 'none' : 'default';
    });

    resetCustomShapeBtn.addEventListener('click', () => {
      drawnStrokes = [];
      currentStroke = [];
      customCtx.clearRect(0, 0, customShapeCanvas.width, customShapeCanvas.height);
    });

    function redrawCustomShapeCanvas() {
      customCtx.clearRect(0, 0, customShapeCanvas.width, customShapeCanvas.height);
      customCtx.beginPath();
      drawnStrokes.forEach(stroke => {
        if (stroke.length > 0) {
          customCtx.moveTo(stroke[0][0], stroke[0][1]);
          for (let i = 1; i < stroke.length; i++) {
            customCtx.lineTo(stroke[i][0], stroke[i][1]);
          }
        }
      });
      if (currentStroke.length > 0) {
        customCtx.moveTo(currentStroke[0][0], currentStroke[0][1]);
        for (let i = 1; i < currentStroke.length; i++) {
          customCtx.lineTo(currentStroke[i][0], currentStroke[i][1]);
        }
      }
      customCtx.strokeStyle = 'black';
      customCtx.lineWidth = 2;
      customCtx.stroke();
    }

    function eraseAtPoint(x, y) {
      const newStrokes = [];
      drawnStrokes.forEach(stroke => {
        let subStroke = [];
        stroke.forEach(pt => {
          const dx = pt[0] - x;
          const dy = pt[1] - y;
          if (Math.sqrt(dx * dx + dy * dy) > eraserRadius) {
            subStroke.push(pt);
          } else {
            if (subStroke.length > 0) {
              newStrokes.push(subStroke);
              subStroke = [];
            }
          }
        });
        if (subStroke.length > 0) {
          newStrokes.push(subStroke);
        }
      });
      drawnStrokes = newStrokes;
      currentStroke = currentStroke.filter(pt => {
        const dx = pt[0] - x;
        const dy = pt[1] - y;
        return Math.sqrt(dx * dx + dy * dy) > eraserRadius;
      });
      redrawCustomShapeCanvas();
      drawEraserIndicator(x, y);
    }

    function drawEraserIndicator(x, y) {
      customCtx.save();
      customCtx.beginPath();
      customCtx.arc(x, y, eraserRadius, 0, 2 * Math.PI);
      customCtx.strokeStyle = 'red';
      customCtx.lineWidth = 1;
      customCtx.setLineDash([4, 2]);
      customCtx.stroke();
      customCtx.restore();
    }

    customShapeCanvas.addEventListener('mousedown', (e) => {
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke = [];
        currentStroke.push([x, y]);
      }
    });
    customShapeCanvas.addEventListener('mousemove', (e) => {
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (eraserActive) {
        if (e.buttons === 1) {
          eraseAtPoint(x, y);
        } else {
          redrawCustomShapeCanvas();
          drawEraserIndicator(x, y);
        }
      } else {
        if (e.buttons !== 1) return;
        currentStroke.push([x, y]);
        redrawCustomShapeCanvas();
      }
    });
    customShapeCanvas.addEventListener('mouseup', () => {
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });
    customShapeCanvas.addEventListener('mouseleave', () => {
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });

    customShapeCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke = [];
        currentStroke.push([x, y]);
      }
    });
    customShapeCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke.push([x, y]);
        redrawCustomShapeCanvas();
      }
    });
    customShapeCanvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });

    saveCustomShapeBtn.addEventListener('click', () => {
      let combinedPoints = [];
      drawnStrokes.forEach(stroke => {
        combinedPoints = combinedPoints.concat(stroke);
      });
      if (combinedPoints.length > 1) {
        customShapePoints = combinedPoints.map(pt => [pt[0] / customShapeCanvas.width, pt[1] / customShapeCanvas.height]);
      }
      customShapeModal.style.display = 'none';
      drawAvatar();
    });
    cancelCustomShapeBtn.addEventListener('click', () => {
      customShapeModal.style.display = 'none';
      shapeSelect.value = 'circle';
      drawAvatar();
    });
    shapeSelect.addEventListener('change', () => {
      if (shapeSelect.value === 'custom') {
        customShapeModal.style.display = 'flex';
      }
      drawAvatar();
    });

    /* ========= 15. Share button ========= */
    shareAvatarBtn.addEventListener('click', () => {
      canvas.toBlob(blob => {
        const file = new File([blob], 'avatar.png', { type: 'image/png' });
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          navigator.share({
            files: [file],
            title: 'My Avatar',
            text: 'Check out the avatar I created!'
          }).catch(console.error);
        localStorage.setItem('shared_avatars', String(Number(localStorage.getItem('shared_avatars') || '0') + 1));
        } else {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'avatar.png';
          a.click();
        }
      });
    });

    /* ========= 16. Binding events for other fields ========= */
    const allInputs = document.querySelectorAll('.tools input, .tools select, .tools textarea');
    allInputs.forEach(el => {
      el.addEventListener('input', drawAvatar);
      el.addEventListener('change', drawAvatar);
    });
    
    function formatNumber(n) {
      return n.toLocaleString('en-US');
    }
    function updateCharCount() {
      document.getElementById('charCount').textContent = formatNumber(textInput.value.length) + "/" + formatNumber(10000);
    }
    /* Text input validation for bad words */
    textInput.addEventListener('blur', () => {
      if (containsBadWordsLocal(textInput.value || '')) {
        showModal('Field contains inappropriate words.');
        textInput.value = '';
        try { if (typeof drawAvatar === 'function') drawAvatar(); } catch(e) {}
      }
    });
    textInput.addEventListener('input', updateCharCount);

    let cursorX = 0;
    let cursorY = 0;
    let isHoveringCanvas = false;
    canvas.addEventListener('mousemove', e => {
      isHoveringCanvas = true;
      const rect = canvas.getBoundingClientRect();
      cursorX = e.clientX - rect.left;
      cursorY = e.clientY - rect.top;
    });
    canvas.addEventListener('mouseleave', () => {
      isHoveringCanvas = false;
    });
    bgColorInput.addEventListener('input', () => {
      drawAvatar();
      if (isHoveringCanvas) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(cursorX, cursorY, 20, 0, 2 * Math.PI);
        ctx.fillStyle = bgColorInput.value;
        ctx.fill();
        ctx.restore();
      }
    });

    /* ========= Text dragging logic ========= */
    function handleMouseDown(e) {
      if (dragTextMode.getAttribute('data-checked') !== 'true') return;
      isDraggingText = true;
      const rect = canvas.getBoundingClientRect();
      startDragX = e.clientX - rect.left;
      startDragY = e.clientY - rect.top;
      dragStartTextX = textPosX;
      dragStartTextY = textPosY;
    }

    function handleMouseMove(e) {
      if (!isDraggingText || dragTextMode.getAttribute('data-checked') !== 'true') return;
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      textPosX = dragStartTextX + (currentX - startDragX);
      textPosY = dragStartTextY + (currentY - startDragY);
      drawAvatar();
    }

    function handleMouseUp() {
      isDraggingText = false;
    }

    function handleTouchStart(e) {
      if (dragTextMode.getAttribute('data-checked') !== 'true') return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      startDragX = touch.clientX - rect.left;
      startDragY = touch.clientY - rect.top;
      dragStartTextX = textPosX;
      dragStartTextY = textPosY;
      isDraggingText = true;
    }

    function handleTouchMove(e) {
      if (!isDraggingText || dragTextMode.getAttribute('data-checked') !== 'true') return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const currentX = touch.clientX - rect.left;
      const currentY = touch.clientY - rect.top;
      textPosX = dragStartTextX + (currentX - startDragX);
      textPosY = dragStartTextY + (currentY - startDragY);
      drawAvatar();
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      isDraggingText = false;
    }

    function enableTextDragging() {
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('mouseleave', handleMouseUp);
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      canvas.style.cursor = 'move';
    }

    function disableTextDragging() {
      canvas.removeEventListener('mousedown', handleMouseDown);
      canvas.removeEventListener('mousemove', handleMouseMove);
      canvas.removeEventListener('mouseup', handleMouseUp);
      canvas.removeEventListener('mouseleave', handleMouseUp);
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchmove', handleTouchMove);
      canvas.removeEventListener('touchend', handleTouchEnd);
      canvas.style.cursor = 'default';
    }

    dragTextMode.addEventListener('click', () => {
      const isChecked = dragTextMode.getAttribute('data-checked') === 'true';
      dragTextMode.setAttribute('data-checked', isChecked ? 'false' : 'true');
      const icon = dragTextMode.querySelector('i');
      icon.className = isChecked ? 'fa-solid fa-toggle-off' : 'fa-solid fa-toggle-on';
      
      if (!isChecked) {
        enableTextDragging();
      } else {
        disableTextDragging();
      }
    });

    /* ========= 17. Initialization ========= */
    updateMediaSettingsVisibility();
    drawAvatar();
    const shareBtnLocal = document.getElementById('shareAvatar');
    if (shareBtnLocal && shareBtnLocal.disabled === true) {
      shareBtnLocal.style.background = 'gray';
    }

    // enable label clicks for toggle-icon elements on this page
    document.querySelectorAll('label[for]').forEach(label => {
      const id = label.getAttribute('for');
      if (!id) return;
      const target = document.getElementById(id);
      if (target && target.classList && target.classList.contains('toggle-icon')) {
        label.style.cursor = 'pointer';
        label.addEventListener('click', () => target.click());
      }
    });

    // attach input validation for avatar EN page inputs/textareas
    document.querySelectorAll('input, textarea').forEach(el => {
      const handler = () => {
        try {
          if (containsBadWordsLocal(el.value || '')) {
            showModal('Field contains inappropriate words.');
            el.value = '';
          }
        } catch (e) {}
      };
      el.addEventListener('blur', handler);
      el.addEventListener('input', handler);
    });

    // Add click handlers for alignCheckbox and grayscaleCheckbox
    alignCheckbox.addEventListener('click', () => {
      const isChecked = alignCheckbox.getAttribute('data-checked') === 'true';
      alignCheckbox.setAttribute('data-checked', isChecked ? 'false' : 'true');
      const icon = alignCheckbox.querySelector('i');
      icon.className = isChecked ? 'fa-solid fa-toggle-off' : 'fa-solid fa-toggle-on';
      drawAvatar();
    });

    grayscaleCheckbox.addEventListener('click', () => {
      const isChecked = grayscaleCheckbox.getAttribute('data-checked') === 'true';
      grayscaleCheckbox.setAttribute('data-checked', isChecked ? 'false' : 'true');
      const icon = grayscaleCheckbox.querySelector('i');
      icon.className = isChecked ? 'fa-solid fa-toggle-off' : 'fa-solid fa-toggle-on';
      drawAvatar();
    });
  </script>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
  if (window.Telegram?.WebApp) {
      const tg = window.Telegram.WebApp;
      tg.ready();
      tg.BackButton.show();
      tg.BackButton.onClick(() => {
          window.location.href = 'main.html';
      });
      tg.SettingsButton.hide();
  }
  </script>
  <script src="apply_app_view.js"></script>
</body>
</html>